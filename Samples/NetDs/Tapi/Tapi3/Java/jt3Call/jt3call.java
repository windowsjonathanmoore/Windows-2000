/*++
Copyright (c) 1997-2000  Microsoft Corporation
Module Name:
        jt3call.java
Abstract:

Author:

Notes:
Revision History:
--*/


import java.awt.*;
import java.applet.*;
import java.util.*;
import com.ms.com.*;
import com.ms.ui.*;
import tapi3.*;
import quartz.*;
import rend.*;
import sdpblb.*;
import h323msp.*;
import confmsp.PARTICIPANT_EVENT;

import appctrls;



/////////////////////////////////////////////////////////////////////////
//  CLASS: JT3Call
//
//  PURPOSE: TAPI 3.0 test program
//  DATE CREATED : (NT 5.0 - BETA 1)	July 14, 1997
//  DATE MODIFIED: (NT 5.0 - BETA 2)	March 30, 1998
//              
//  DESCRIPTION:
//      Applet/application that allows the user to make outgoing calls
//      using TAPI 3.0.
//
/////////////////////////////////////////////////////////////////////////
/**
 * @com.register ( clsid=BA53613A-308A-11D2-8E54-00A0C9AC4B3A, typelib=BA536135-308A-11D2-8E54-00A0C9AC4B3A )
 */
public class jt3call extends Applet
	implements TapiConstants,   // misc. constants
	tapi3.TERMINAL_DIRECTION,
	tapi3.DISCONNECT_CODE,  // DC_xxx constants
	tapi3.TAPI_EVENT,
	DIRECTORY_TYPE,
	DIRECTORY_OBJECT_TYPE
{
	// Application name.
	public static final String APP_NAME = "Java TAPI 3.0 Caller";

	// Default number of video window terminals.
	private static final int MIN_VIDEOWNDS = 0;
	private static final int DEF_VIDEOWNDS = 5;
	private static final int MAX_VIDEOWNDS = 10;

	// Index of the selected address
	private int m_iSelAddr;
	// True if running as stand alone app.
	public boolean m_fStandAlone = false;

	// Parent frame of the app.
	private Frame m_ParentFrame = null;

	// Resource Wizard generated UI.
	private final appctrls ctrls = new appctrls(this);

	// Main interface to the TAPI component.
	private tapi3.ITTAPI m_Tapi = null;

	// Main interface to the rendezvous control component.
	private ITRendezvous m_Rend = null;

	// The current call or null if there isn't one.
	public tapi3.ITBasicCallControl m_Call = null;

	// Stores ITAddress interfaces for addresses displayed in the
	// source address combo box.
	private Vector m_Addresses = new Vector();

	// Stores ITStream interfaces for the current call
	private tapi3.ITStream m_Streams[];
	
	// Stores ITAddressCapabilities interfaces for addresses displayed in the
	// source address combo box.
	private Vector m_VecAddressCapabilities = new Vector();


	// Stores ITTerminal interfaces for the (static) terminals in the terminals listbox.
	private Vector m_StaticTerms = new Vector();

	// Stores ITTerminal interfaces for all the terminals
	private tapi3.ITTerminal m_mediaTerms[];

	// destination address types
	DESTINATION_TYPE[] destAddressType = new DESTINATION_TYPE[5]; 


	// chosen DestinationType
	int DstAddress;

	// the call notification class, which is used
	// to receive tapi events
	CallNot callnot;

	// the ConnectionPointCookie is Java mechanism used 
	// to implement COM callback 
	// since IConnectionPointContainer and IConnectionPoint
	// are not available from Java (SDK ver. 2.01)
	ConnectionPointCookie cookie;
	AppFrame frame;
	/////////////////////////////////////////////////////////////////////
	// init
	//
	// Performs applet initialization.
	/////////////////////////////////////////////////////////////////////
	public void init()
	{
		frame = new AppFrame(APP_NAME);

		// Must show Frame before we size it so insets() will return valid values
		//----------------------------------------------------------------------
		frame.show();
		frame.hide();
		frame.resize(frame.insets().left + frame.insets().right  + 430,
					 frame.insets().top  + frame.insets().bottom + 350);
		frame.hide();
		frame.show();

		// The following code starts the applet running within the frame window.
		// It also calls GetParameters() to retrieve parameter values from the
		// command line, and sets m_fStandAlone to true to prevent init() from
		// trying to get them from the HTML page.
		//----------------------------------------------------------------------


		frame.m_App = this;
		frame.add("Center", this);
		m_fStandAlone = true;
		frame.show();    
		
		// select a font to use (ctrls needs this)
		Font font = new Font("Dialog", Font.PLAIN, 8);
		this.setFont(font);

		// setup the UI generated by the Resource Wizard
		ctrls.CreateControls();
		ctrls.lstStaticTerms.setMultipleSelections(true);
		ctrls.tfStatusBox.setEditable(false);
		ctrls.tfVideoWnds.setText(DEF_VIDEOWNDS + "");


		for (int i=0; i<5; i++)
		{
			destAddressType[i] = new DESTINATION_TYPE(); 
		}
		destAddressType[0].name = "PHONE NUMBER";
		destAddressType[0].Tapi3Type = LINEADDRESSTYPE_PHONENUMBER;
		destAddressType[1].name = "EMAIL NAME";
		destAddressType[1].Tapi3Type = LINEADDRESSTYPE_EMAILNAME;
		destAddressType[2].name = "DOMAIN NAME";
		destAddressType[2].Tapi3Type = LINEADDRESSTYPE_DOMAINNAME;
		destAddressType[3].name = "IP ADDRESS ";
		destAddressType[3].Tapi3Type = LINEADDRESSTYPE_IPADDRESS;
		destAddressType[4].name = "MULTICAST CONFERENCE";
		destAddressType[4].Tapi3Type = LINEADDRESSTYPE_SDP;


		for (int i=0; i<destAddressType.length; i++)
		{
			ctrls.cmbDstAddr.addItem(destAddressType[i].name);
		}
		// initialize the destination address type
		DstAddress = 0;


		//DisableControls();
		if (m_fStandAlone) 
		{
			ctrls.btnClose.enable();
		}

		// get parent frame to use for message boxes
		Container parent = getParent();
		while ((parent != null) && (!(parent instanceof Frame))) 
		{
			parent = parent.getParent();
		}
		m_ParentFrame = (Frame) parent;

		// resize the frame if running as standalone app
		if (m_fStandAlone) 
		{
			m_ParentFrame.pack();
			m_ParentFrame.setResizable(false);
		}

		if(InitializeTAPI()==0)
			return ;

		

		// app initialized... enable controls
		ctrls.cmbSrcAddr.enable();
		ctrls.cmbDstAddr.enable();
		ctrls.lstStaticTerms.enable();
		ctrls.btnConnect.enable();
	}
	/////////////////////////////////////////////////////////////////////
	// initmain
	//
	// Performs application initialization.
	/////////////////////////////////////////////////////////////////////

	public void initmain()
	{
		
		
		// select a font to use (ctrls needs this)
		Font font = new Font("Dialog", Font.PLAIN, 8);
		this.setFont(font);

		// setup the UI generated by the Resource Wizard
		ctrls.CreateControls();
		ctrls.lstStaticTerms.setMultipleSelections(true);
		ctrls.tfStatusBox.setEditable(false);
		ctrls.tfVideoWnds.setText(DEF_VIDEOWNDS + "");


		for (int i=0; i<5; i++)
		{
			destAddressType[i] = new DESTINATION_TYPE(); 
		}
		destAddressType[0].name = "PHONE NUMBER";
		destAddressType[0].Tapi3Type = LINEADDRESSTYPE_PHONENUMBER;
		destAddressType[1].name = "EMAIL NAME";
		destAddressType[1].Tapi3Type = LINEADDRESSTYPE_EMAILNAME;
		destAddressType[2].name = "DOMAIN NAME";
		destAddressType[2].Tapi3Type = LINEADDRESSTYPE_DOMAINNAME;
		destAddressType[3].name = "IP ADDRESS ";
		destAddressType[3].Tapi3Type = LINEADDRESSTYPE_IPADDRESS;
		destAddressType[4].name = "MULTICAST CONFERENCE";
		destAddressType[4].Tapi3Type = LINEADDRESSTYPE_SDP;


		for (int i=0; i<destAddressType.length; i++)
		{
			ctrls.cmbDstAddr.addItem(destAddressType[i].name);
		}
		// initialize the destination address type
		DstAddress = 0;


		//DisableControls();
		if (m_fStandAlone) 
		{
			ctrls.btnClose.enable();
		}

		// get parent frame to use for message boxes
		Container parent = getParent();
		while ((parent != null) && (!(parent instanceof Frame))) 
		{
			parent = parent.getParent();
		}
		m_ParentFrame = (Frame) parent;

		// resize the frame if running as standalone app
		if (m_fStandAlone) 
		{
			m_ParentFrame.pack();
			m_ParentFrame.setResizable(false);
		}
		if(InitializeTAPI()==0)
			return;


		// app initialized... enable controls
		ctrls.cmbSrcAddr.enable();
		ctrls.cmbDstAddr.enable();
		ctrls.lstStaticTerms.enable();
		ctrls.btnConnect.enable();
	}

	/////////////////////////////////////////////////////////////////////
	// stop
	//
	// Called when the user leaves the applet's webpage.
	/////////////////////////////////////////////////////////////////////
	public void stop()
	{
		if (m_Call != null) 
		{
			DisconnectTheCall(DC_NORMAL);
		}

		ctrls.btnDisconnect.disable();
		ctrls.btnConnect.enable();
		ctrls.cmbSrcAddr.enable();
		ctrls.cmbDstAddr.enable();
		ctrls.tfDestAddr.enable();
		ctrls.lstStaticTerms.enable();
		SetStatusMessage("Ready");
	}

	/////////////////////////////////////////////////////////////////////
	// destroy
	//
	// Called when the applet is destroyed by the browser.
	/////////////////////////////////////////////////////////////////////
	public void destroy()
	{
	
		try 
		{		
			if (m_Tapi != null) 
			{
			
				m_Tapi.Shutdown();
			}
			CleanUp();
		}
		catch (ComException e) 
		{
			e.printStackTrace();
			DoMessage("An error occurred while trying to shutdown TAPI");
		}
		
	}

	/////////////////////////////////////////////////////////////////////
	// CleanUp
	//
	// Release All the interfaces
	/////////////////////////////////////////////////////////////////////
	public void CleanUp()
	{
		int i;

		ctrls.btnDisconnect.disable();
		
		SetStatusMessage("Disconnected");			
		ctrls.btnConnect.enable();
		ctrls.cmbSrcAddr.enable();
		ctrls.cmbDstAddr.enable();
		ctrls.tfDestAddr.enable();
		ctrls.tfVideoWnds.enable();
		ctrls.lstStaticTerms.enable();


		for(i=0;i<m_Addresses.size();i++)
		{
			if(m_Addresses.elementAt(i)!=null)
			{
				ComLib.release(m_Addresses.elementAt(i));
				m_Addresses.setElementAt(null,i);
			}
		}
		
		if(m_Rend!=null)
		{
			ComLib.release(m_Rend);
			m_Rend=null;
		}

		if(m_Tapi!=null)
		{
			ComLib.release(m_Tapi);
			m_Tapi=null;
		}

		if(m_Call!=null)
		{
			ComLib.release(m_Call);
			m_Call=null;
		}
		
		if(m_Streams!=null)
		{
			for(i=0;i<m_Streams.length;i++)
			{
				if(m_Streams[i]!=null)
				{
					ComLib.release(m_Streams[i]);
					m_Streams[i]=null;
				}
			}
		}
		for(i=0;i<m_VecAddressCapabilities.size();i++)
		{
			if(m_VecAddressCapabilities.elementAt(i)!=null)
			{
				ComLib.release(m_VecAddressCapabilities.elementAt(i));
				m_VecAddressCapabilities.setElementAt(null,i);
			}
		}
		if(m_mediaTerms!=null)
			for(i=0;i<m_mediaTerms.length;i++)
				m_mediaTerms[i]=null;
		
	}
	
	/////////////////////////////////////////////////////////////////////
	// InitializeTAPI
	//
	// initializes tapi
	/////////////////////////////////////////////////////////////////////
	public int InitializeTAPI()
	{
		if(m_Tapi!=null)
			return 0;
		SetStatusMessage("Initializing TAPI 3.0...");
		try 
		{
			m_Tapi = new TAPI();
			m_Tapi.Initialize();
			m_Tapi.putEventFilter(
				 TE_TAPIOBJECT |
				 TE_ADDRESS |
				 TE_CALLNOTIFICATION |
				 TE_CALLSTATE |
				 TE_CALLMEDIA |
				 TE_CALLHUB |
				 TE_CALLINFOCHANGE |
				 TE_PRIVATE |
				 TE_REQUEST |
				 TE_AGENT |
				 TE_AGENTSESSION |
				 TE_QOSEVENT |
				 TE_AGENTHANDLER |
				 TE_ACDGROUP |
				 TE_QUEUE |
				 TE_DIGITEVENT |
				 TE_GENERATEEVENT); 
			    
			SetStatusMessage("Initialization done...");

		}
		catch (ComException e) 
		{
			DoMessage("Fatal Error: Could not initialize TAPI 3.0");
			m_Tapi.Shutdown();
			m_Tapi = null;
			if (m_fStandAlone) 
			{
				System.exit(0);
			}
			else 
			{
				SetStatusMessage("Could not initialize TAPI 3.0");
				return 0;
			}
		}


		// initialize the rendezvous control
		SetStatusMessage("Initializing the Rendezvous Control...");
		try 
		{
			m_Rend = new Rendezvous();
		}
		catch (ComException e) 
		{
			DoMessage("Fatal Error: Could not initialize the Rendezvous Control");
			m_Tapi.Shutdown();
			m_Tapi = null;
			if (m_fStandAlone) 
			{
				System.exit(0);
			}
			else 
			{
				SetStatusMessage("Could not initialize the Rendezvous Control");
				return 0;
			}
		}
		// get initial data and display it
		SetStatusMessage("Enumerating addresses...");
		if (EnumerateAddresses() < 0) 
		{
			DoMessage("Fatal Error: Could not enumerate addresses");
			m_Tapi.Shutdown();
			m_Tapi = null;
			if (m_fStandAlone) 
			{
				System.exit(0);
			}
			else 
			{
				SetStatusMessage("Could not enumerate addresses");
				return 0;
			}
		}
		
		SetStatusMessage("Ready");

		return 1;
	}
	/////////////////////////////////////////////////////////////////////
	// action
	// (the event handler for all AWT constructs - Java event model 1.0)
	// Event.ACTION_EVENT event handler.
	/////////////////////////////////////////////////////////////////////
	public boolean action(Event evt, Object arg)
	{
		if (evt.target == ctrls.cmbSrcAddr) 
		{
			//index of the sselected source address
			m_iSelAddr=ctrls.cmbSrcAddr.getSelectedIndex();
			if (EnumerateStaticTerms() < 0) 
			{
				DoMessage("Warning: Could not enumerate static " +
						  "terminals for the current chosen address");
			}
		}
		else if (evt.target == ctrls.cmbDstAddr) 
		{
			// destination address type selected
			int tmp = ctrls.cmbDstAddr.getSelectedIndex();
			if (tmp > -1)
			{
				DstAddress = tmp;
			}
		}
		else if (arg.equals("Connect")) 
		{
			// connect button pressed
			if (MakeTheCall()) 
			{
				ctrls.btnDisconnect.enable();
				ctrls.btnConnect.disable();
				ctrls.cmbSrcAddr.disable();
				ctrls.tfDestAddr.disable();
				ctrls.tfVideoWnds.disable();
				ctrls.lstStaticTerms.disable();
				SetStatusMessage("Connected");
			}
			else 
			{
				DoMessage("The call failed to connect");
				CleanUp();
				InitializeTAPI();			
			}
		}
		else if (arg.equals("Disconnect")) 
		{
			// disconnect button pressed
			if (!DisconnectTheCall(DC_NORMAL)) 
			{
				DoMessage("An error occurred while disconnecting, " +
						  "but it will be ignored");
			}
			
			//CleanUp();
			CleanUp();
			InitializeTAPI();			
			SetStatusMessage("Disconnected");
		}
		else if (arg.equals("Close")) 
		{
			// close button pressed.  This button is enabled only when
			// running as an application.  Since a browser would close
			// the applet by calling stop and destroy, we should also.
			stop();
			destroy();

			System.exit(0);
		}
		else 
		{
			return super.action(evt, arg);
		}
		return true;
	}

	/////////////////////////////////////////////////////////////////////
	// EnumerateAddresses
	//
	// Finds all local addresses and adds their names to the source
	// address combo and add their interfaces to the m_Addresses vector.
	// Returns the number of addresses found or -1 on error.
	//
	// This method should be called only once since, once added, address
	// name cannot be removed from the source address combo.
	/////////////////////////////////////////////////////////////////////
	private int EnumerateAddresses()
	{
		Variant			  var;
		ITCollection   itc;
		ITAddress     address;
		int					 n;
		String			   addrname;

		m_Addresses.removeAllElements();
		ctrls.cmbSrcAddr.removeAll();

		try 
		{
			// get the collection interface for addresses
			var = m_Tapi.getAddresses();
			itc = (ITCollection) var.toDispatch();

			// Walk through the collection.  Note that collections start
			// at index 1 and end at index itc.getCount().
			for (n=1; n <= itc.getCount(); n++) 
			{
				// get the next address
				var = itc.getItem(n);
				address = (ITAddress) var.toObject();

				// get the address name
				addrname=address.getAddressName();
				
				// display the address name and store its interface
				ctrls.cmbSrcAddr.addItem(addrname);
				m_Addresses.addElement(address);
			}
			return n - 1;
		}
		catch (ComException e) 
		{
			e.printStackTrace();
			return -1;
		}
	}

	/////////////////////////////////////////////////////////////////////
	// EnumerateStaticTerms
	//
	// Finds available static terminals and adds their names to the
	// static terminals listbox and their interfaces to the m_StaticTerms
	// vector.  Returns the number of terminals found or -1 on error.
	/////////////////////////////////////////////////////////////////////
	private int EnumerateStaticTerms()
	{
		ITTerminalSupport	termSupp;
		Variant						var;
		ITCollection			 itc;
		tapi3.ITTerminal				 terminal;
		String						 termClass;
		int							    n;
		ITAddress address;
		address=(ITAddress)m_Addresses.elementAt(m_iSelAddr);
		

		ctrls.lstStaticTerms.clear();
		m_StaticTerms.removeAllElements();

		if (address == null)
			return -1;

		try 
		{
			
			// get the terminal support interface on the address
			termSupp = (ITTerminalSupport) address;

			// get the collection interface for static terminals
			var = termSupp.getStaticTerminals();
			

			itc = (ITCollection) var.toDispatch();
			
			for (n=1; n <= itc.getCount(); n++) 
			{
				// get the next static terminal
				var = itc.getItem(n);
				terminal = (tapi3.ITTerminal) var.toObject();
				String strDir=new String("");
				if(terminal.getMediaType()==TAPIMEDIATYPE_AUDIO)
				{
					if(terminal.getDirection()==tapi3.TERMINAL_DIRECTION.TD_RENDER) 
						strDir+=" Render";
					else
						strDir+=" Capture";
				}
				// display the terminal name and store its interface
				ctrls.lstStaticTerms.addItem(terminal.getName()+strDir);
				m_StaticTerms.addElement(terminal);
			}
			return n - 1;
		}
		catch (Exception e) 
		{
			e.printStackTrace();
			return -1;
		}
	}

	/////////////////////////////////////////////////////////////////////
	// MakeTheCall
	//
	// Sets up and makes a call.
	/////////////////////////////////////////////////////////////////////
	private boolean MakeTheCall()
	{
		String				  destAddr, dAddr;
		ITSubStreamControl pSubStreamControl;
		ITAddress         srcAddr;
		ITAddressCapabilities  m_ITAddressCapabilities;
		tapi3.ITTerminal[]      staticTerms, dynamicTerms, temp;
		int						 nVideoWnds;
		ITCallInfo callInfo;
		int CallState;
		tapi3.ITTerminal[]	  mediaTerms;
		SafeArray          sa;
		Variant               var;
		confmsp.ITParticipantControl pParticipantControl;
		confmsp.IEnumParticipant pEnumPart;
		confmsp.ITParticipant part;
		Variant						avar;
		ITCollection			 itc;
		ITCallInfo				 pCallInfo;
		IVideoWindow         VideoWindow;
		tapi3.ITTerminal	            aterm;
		int 			              astr;

		Variant					pvar;
		ITCollection		 pitc;
		String					pname;
		int         ulRegister, ulAdvise;
		
		try
		{
			// get the destination address
			dAddr = ctrls.tfDestAddr.getText().trim();
			if (dAddr.equals("")) 
			{
				DoMessage("The destination address is invalid");
				return false;
			}
				
			
			 // create an instance of the callback class
			 callnot = new CallNot(this);

              // hook it to TAPI
              cookie = new ConnectionPointCookie(
                                      m_Tapi, callnot,
                                      ITTAPIEventNotification.class
                                      );
			m_iSelAddr=ctrls.cmbSrcAddr.getSelectedIndex();
			//get the source address
			srcAddr=(ITAddress) m_Addresses.elementAt(m_iSelAddr);
			if (destAddressType[DstAddress].Tapi3Type == LINEADDRESSTYPE_SDP)
			{
				destAddr = CheckConference(dAddr);
				if (destAddr == dAddr)
				{
					DoMessage("This is not a correct conference target or address");
					return false;
				}
			}
			else
			{
				destAddr = dAddr;
			}

			// get the number of video windows
			nVideoWnds = GetNumVideoWnds();
			if (nVideoWnds < MIN_VIDEOWNDS || nVideoWnds > MAX_VIDEOWNDS) 
			{
				DoMessage("Please enter a number from " + MIN_VIDEOWNDS +
						  " to " + MAX_VIDEOWNDS +
						  " for the number of video windows");
				return false;
			}
			
			if(CreateMediaTerminals()==0)
			{
				DoMessage("Failed to create media terminals");
				return false;
			}
		}
		catch(Exception e)
		{
			DoMessage("Failure while preparing to make the call");
			return false;
		}

		try 
		{

			String strServiceProviderName=srcAddr.getServiceProviderName();
			int dwMEDIATYPE;
			if (strServiceProviderName.equals("unimdm.tsp"))
				dwMEDIATYPE = TAPIMEDIATYPE_AUDIO;					
			else				
				dwMEDIATYPE = TAPIMEDIATYPE_VIDEO | TAPIMEDIATYPE_AUDIO;
   		    ulAdvise = 0;
   		    
			if(ctrls.cmbSrcAddr.getSelectedItem().indexOf("IPCONF")==-1)
			{
	  			System.out.println("trying to Register call notifications"); 

	  		   ulRegister = m_Tapi.RegisterCallNotifications(
	  				srcAddr,
				    true,
	                true,
				  dwMEDIATYPE,
				  ulAdvise
				 );			
				System.out.println("Registered call notifications");
			}
			// create a call between srcAddr and destAddr
			m_Call = srcAddr.CreateCall(destAddr, destAddressType[DstAddress].Tapi3Type,dwMEDIATYPE);

			//Enumerate the streams
			if(!EnumerateStreams())
			{
				DoMessage("Failed to get Streams ");
				return false;
			}

			//Select the terminals
			// attach the media-terminals to the call
			SelectTerminals(strServiceProviderName);
			// make the call (true = synchronous)

			m_Call.Connect(true);
			
			do
			{				
				callInfo=(ITCallInfo)m_Call;
				CallState=callInfo.getCallState();	
				if(CallState==tapi3.CALL_STATE.CS_DISCONNECTED)
				{
					DoMessage("The Call Failed to connect");
					return false;
				}
			}while(CallState!=tapi3.CALL_STATE.CS_CONNECTED);
			boolean bFlag=true;
			int iCnt=0;
			if((ctrls.cmbSrcAddr.getSelectedItem().indexOf("H323")!=-1)||
			(ctrls.cmbSrcAddr.getSelectedItem().indexOf("IPCONF")!=-1))

			{
			do			
			{	
				if(m_Streams[iCnt]==null)
					continue;
					
				if((m_Streams[iCnt].getMediaType()==TAPIMEDIATYPE_VIDEO)&&(srcAddr.getServiceProviderName().equals("unimdm.tsp")))
					continue;
				// only if it is the video render terminal 	
				if(m_Streams[iCnt].getMediaType()==TAPIMEDIATYPE_VIDEO)
				{					
					var=m_Streams[iCnt].getTerminals();
					pitc=(ITCollection)var.toDispatch();
					for(int tCnt=1;tCnt<=pitc.getCount();tCnt++)
					{					
						var=pitc.getItem(tCnt);
						if(((tapi3.ITTerminal)(var.toObject())).getDirection()==tapi3.TERMINAL_DIRECTION.TD_RENDER)
						{
							VideoWindow=(IVideoWindow)((tapi3.ITTerminal)(var.toObject()));
							VideoWindow.putAutoShow(-1);
								System.out.println("enabled ");
							
						}
					}
					
				}
				
				iCnt++;
			}while(iCnt<m_Streams.length);

			}

			
			return true;
		}
		catch (Exception e) 
		{
			e.printStackTrace();
			DisconnectTheCall(DC_NORMAL);
			return false;
		}
	}

	/***
	 Associates the terminals with the streams
	 ****/
	private void SelectTerminals(String strServiceProviderName)
	{
		int iSelected[];
		IVideoWindow VideoWindow;
		iSelected = new int[m_Streams.length];
		int iCaptureStream=-1;
		for (int i=0;i<m_Streams.length;i++)
			iSelected[i]=0;
		
		for (int iTerm=0; iTerm < m_mediaTerms.length-1; iTerm++) 
		{
			if(m_mediaTerms[iTerm]!=null)
			{
				int termDirec;
				int lMedia;
				termDirec = m_mediaTerms[iTerm].getDirection();	
				lMedia	  = m_mediaTerms[iTerm].getMediaType();
				if((lMedia==TAPIMEDIATYPE_VIDEO)&&(strServiceProviderName.equals("unimdm.tsp")))
				{
					continue;
				}
				if((lMedia==TAPIMEDIATYPE_VIDEO)&&(termDirec == tapi3.TERMINAL_DIRECTION.TD_RENDER))
				{
					VideoWindow = (IVideoWindow) m_mediaTerms[iTerm];
					  VideoWindow.putAutoShow(-1);
					System.out.println("Enable");

				}				for(int iStream=0;iStream<m_Streams.length;iStream++)
				{

					
					if(iSelected[iStream]==0) //take only streams that dont have terminals
					{
						int  StrmTermDirec;
						int lStreamMedia;
						StrmTermDirec = m_Streams[iStream].getDirection();
						lStreamMedia  = m_Streams[iStream].getMediaType();						
						if((lStreamMedia==TAPIMEDIATYPE_VIDEO)&&
						   (StrmTermDirec==tapi3.TERMINAL_DIRECTION.TD_CAPTURE))
						{
						//note the position of the capture stream
							iCaptureStream=iStream;
						}
						
						if((lMedia==lStreamMedia)&&(termDirec==StrmTermDirec))
						{
							if((m_Streams[iStream].getMediaType()==TAPIMEDIATYPE_VIDEO)&&(strServiceProviderName.equals("unimdm.tsp")))
							{
								
								continue;
							}
							m_Streams[iStream].SelectTerminal(m_mediaTerms[iTerm]);

							if(ctrls.cmbSrcAddr.getSelectedItem().indexOf("IPCONF")!=-1)
								// there are multiple video render terminals in ipconf so break here 								
								{
								if((lStreamMedia==TAPIMEDIATYPE_VIDEO)&&
								((StrmTermDirec==tapi3.TERMINAL_DIRECTION.TD_RENDER)||
								(StrmTermDirec==tapi3.TERMINAL_DIRECTION.TD_CAPTURE)
								)
								)
									{
									break;
									}
								}
							if(ctrls.cmbSrcAddr.getSelectedItem().indexOf("H323")!=-1)
							{
								if((lStreamMedia==TAPIMEDIATYPE_VIDEO)&&(StrmTermDirec==tapi3.TERMINAL_DIRECTION.TD_CAPTURE))							
								{
									break;
								}
							}
							//set the selected bit on only for streams w/o video render terminals						
							
							iSelected[iStream]=1;							
							
							break;
						}

					}//if
					
				}//for

			}//if

		}//for

		//now enable preview by selecting the capture stream 
		// and a video render terminal
		if(iCaptureStream!=-1)	
		{
			System.out.println("Cap =" +iCaptureStream+" len = "+(m_mediaTerms.length-1));
			m_Streams[iCaptureStream].SelectTerminal(m_mediaTerms[m_mediaTerms.length-1]);
		}
		
	}
	/***
	Enumerate all the streams present in the call 
	 ****/
	
	private boolean EnumerateStreams()
	{

		ITStreamControl pITStreamControl;
		tapi3.ITStream 	pITStream;
		ITSubStreamControl pSubStream;
		ITCollection 	itcStream;
		Variant var;

		pITStreamControl = (ITStreamControl)m_Call;
		
		try
		{
			var = pITStreamControl.getStreams();
			itcStream=(ITCollection) var.toDispatch();
			m_Streams= new tapi3.ITStream[itcStream.getCount()];
			for(int n=1;n<=itcStream.getCount();n++)
			{
				var=itcStream.getItem(n);
				pITStream=(tapi3.ITStream)var.toDispatch();
				m_Streams[n-1]=pITStream;	
			}
			return true;
		}
		catch (ComException e) 
		{
			e.printStackTrace();
			return false;
		}
		
	}

	/***
	Enumerates all conferences present and checks if the
	desired conference is present	
	 ****/
	
	private String CheckConference( String destAddr)
	{
		Variant			     var;
		ITCollection	  itcType;
		int						type;
		boolean				bconf;
		ITAddressCapabilities address;
		try 
		{
			//get the addresscapabilities interface
			address=(ITAddressCapabilities)m_Addresses.elementAt(m_iSelAddr);

			// get the collection interface for address types
			type= address.getAddressCapability(ADDRESS_CAPABILITY.AC_ADDRESSTYPES);
			bconf = false;
			if (type == LINEADDRESSTYPE_SDP)
			{
				// now query the rendezvous
				bconf = true;					
			}

			if (!bconf)
			{
				return destAddr;
			}
			else
			{
				return GetConfBlobName(destAddr);
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			return destAddr;
		}
	}

	/***
	Gets the conference blob from the ILS server 
	 ****/


	private String GetConfBlobName(String destAddr)
	{
		Variant  var;
		ITCollection itc;
		ITDirectory  direc;
		int dtype;
		Variant  avar;
		ITCollection anitc;
		ITDirectoryObject  direcobj;
		ITDirectoryObject  conference;
		ITDirectoryObjectConference conf;
		String st;
		Variant advar;
		String  daddress;
		ITCollection dadc;
		String cname;


		try 
		{            
			// get the enumeration interface for conferences
			// as a collection in a variant
			var = m_Rend.getDefaultDirectories();
			itc = (ITCollection) var.toDispatch();

			// Walk through the collection.  Note that collections start
			// at index 1 and end at index itc.getCount().
			for (int n=1; n <= itc.getCount(); n++) 
			{
				// get the next address
				var = itc.getItem(n);

				// get the conference from the variant
				direc = (ITDirectory) var.toObject();
				dtype=direc.getDirectoryType();

				
				// conferences are stored in ILS servers
				if (dtype == DT_ILS)
				{
					direc.Connect(false);
					avar = direc.getDirectoryObjects(OT_CONFERENCE,"*");
					anitc = (ITCollection) avar.toDispatch();
					
					// Walk through the conferences collection.  
					for (int i=1; i <= anitc.getCount(); i++) 
					{
						// get the next address
						avar = anitc.getItem(i);

						// get the conference from the variant
						conference = (ITDirectoryObject) avar.toObject();
						cname = conference.getName();
						
						if (destAddr.equals(cname))
						{
							// Find out the dialabe addresses of this object.
							// the collection should have only one item
							advar = conference.getDialableAddrs(LINEADDRESSTYPE_SDP);
							dadc = (ITCollection) advar.toDispatch();
							
							// Walk through the dialable addresses collection
							for (int m=1; m <= dadc.getCount(); m++) 
							{
								// get the next address
								advar = dadc.getItem(m);
								// get the address from the variant
								daddress = (String) advar.toString();
								destAddr=daddress;
								return daddress;
							}
						}
					}								
				}
			}
			return destAddr;
		}
		catch (Exception e) 
		{
			e.printStackTrace();
			return destAddr;
		} 
	}
	
	
	
	/////////////////////////////////////////////////////////////////////
	// DisconnectTheCall
	//
	// Disconnects the call using the given disconnect code.  Disconnect
	// codes are defined in the DISCONNECT_CODE interface.
	/////////////////////////////////////////////////////////////////////
	private boolean DisconnectTheCall(int code)
	{
		Variant var;
		IVideoWindow         VideoWindow;
		ITCollection pitc;
		if (m_Call == null)
			return true;
		int i;
		try 
		{		
			ITCallInfo callInfo;
			int CallState;
			CallState=tapi3.CALL_STATE.CS_DISCONNECTED;

			for( i=0;i<m_Streams.length;i++)
				m_Streams[i].StopStream();
				if(m_Call!=null)
				{
					m_Call.Disconnect(code);
				}
			System.out.println("Disconnected");
			return true;
		}
		catch (ComException e) {
			e.printStackTrace();
		}
		finally 
		{
			m_Call = null;

			// force a garbage collect.  This will ensure that terminals
			// get released (unless you have references to them!), etc.
			// If you do not do this you may have effects such as video
			// windows lingering after a call has disconnected.
			System.gc();
		}
		return true;
	}

	
	/////////////////////////////////////////////////////////////////////
	// CreateMediaTerminals
	//
	//
	// Media-terminals are the association of a terminal object and the
	// mediatype that it will use.  In this case, the first mediatype
	// supported by each terminal is used.
	// in the curent version this function is not doing anything useful
	// actually it reduces the performance of the whole application
	// but we kept it here as a typical logical step 
	// that may be needed for other sitiuations
	/////////////////////////////////////////////////////////////////////
	private int CreateMediaTerminals()
	{
		ITAddress address;
		ITTerminalSupport termSupport;
		int[] iStaticTerm;
		int iDynTerm=0;
		int i;
		// get the address  interface 
		address = (ITAddress) m_Addresses.elementAt(m_iSelAddr);			

		//get the number of static terminals
		iStaticTerm = ctrls.lstStaticTerms.getSelectedIndexes();
		if(!(address.getServiceProviderName().equals("unimdm.tsp")))
			iDynTerm=GetNumVideoWnds();
		if(iStaticTerm.length+iDynTerm==0)
			return 0;
		System.out.println("Num of Video Windows = "+iDynTerm);
		m_mediaTerms = new tapi3.ITTerminal[iStaticTerm.length+iDynTerm];
		
		try 
		{
			for (i=0; i < iStaticTerm.length; i++) 
				m_mediaTerms[i] = (tapi3.ITTerminal) m_StaticTerms.elementAt(iStaticTerm[i]);
			if(!(address.getServiceProviderName().equals("unimdm.tsp")))
			{				
				// get the terminal	support	interface on the address
				termSupport	= (ITTerminalSupport) address;
				// create the video	window terminals
				for	(i=0; i	< iDynTerm;	i++) 
				{
					m_mediaTerms[iStaticTerm.length+i] = null;
					m_mediaTerms[iStaticTerm.length+i] = termSupport.CreateTerminal(CLSID_String_VideoWindowTerm, TAPIMEDIATYPE_VIDEO, TD_RENDER);
					System.out.println("Video window "+ i);
					// if failed break out of the loop
					if (m_mediaTerms[iStaticTerm.length+i]== null)
						break;
				}
			}
			return m_mediaTerms.length;
		}
		catch (Exception e) 
		{
			e.printStackTrace();
			return 0;
		}
	}
	/////////////////////////////////////////////////////////////////////
	// GetNumVideoWnds
	//
	// Returns the number entered into the tfVideoWnds text field, or
	// -1 if there was an error.
	/////////////////////////////////////////////////////////////////////
	private int GetNumVideoWnds()
	{
		try 
		{
			if(ctrls.cmbSrcAddr.getSelectedItem().indexOf("IPCONF")!=-1)
				return (Integer.parseInt(ctrls.tfVideoWnds.getText())+1);
			if(ctrls.cmbSrcAddr.getSelectedItem().indexOf("H323")!=-1)
				return 2;			
			return 0;
		}
		catch (NumberFormatException e) 
		{
			e.printStackTrace();
			return -1;
		}
	}


	/////////////////////////////////////////////////////////////////////
	// SetStatusMessage
	//
	// Displays messages in the status box.
	/////////////////////////////////////////////////////////////////////
	public void SetStatusMessage(String msg)
	{
		ctrls.tfStatusBox.setText(msg);
	}

	/////////////////////////////////////////////////////////////////////
	// DoMessage
	//
	// Displays messages in a message box.
	/////////////////////////////////////////////////////////////////////
	private void DoMessage(String msg)
	{
		AwtUIMessageBox msgbox = new AwtUIMessageBox(
													 m_ParentFrame,
													 APP_NAME,
													 msg,
													 AwtUIMessageBox.EXCLAMATION,
													 UIButtonBar.OK
													 );
		msgbox.doModal();
	}

	/////////////////////////////////////////////////////////////////////
	// main
	//
	// Standalone application entry point.  Not called for applets.
	/////////////////////////////////////////////////////////////////////
	public static void main(String[] args)
	{
		// Create Toplevel Window to contain applet japplet
		//----------------------------------------------------------------------
		AppFrame frame = new AppFrame(APP_NAME);

		// Must show Frame before we size it so insets() will return valid values
		//----------------------------------------------------------------------
		frame.show();
		frame.hide();
		frame.resize(frame.insets().left + frame.insets().right  + 430,
					 frame.insets().top  + frame.insets().bottom + 350);
		frame.hide();
		frame.show();

		// The following code starts the applet running within the frame window.
		// It also calls GetParameters() to retrieve parameter values from the
		// command line, and sets m_fStandAlone to true to prevent init() from
		// trying to get them from the HTML page.
		//----------------------------------------------------------------------

		jt3call applet = new jt3call();
		frame.m_App = applet;
		frame.add("Center", applet);
		applet.m_fStandAlone = true;
		frame.show();
		applet.initmain();
	}
}



/////////////////////////////////////////////////////////////////////////
//  CLASS: AppFrame
//
//  DESCRIPTION:
//      Frame for standalone application.
//
/////////////////////////////////////////////////////////////////////////
/**
 * @com.register ( clsid=BA536137-308A-11D2-8E54-00A0C9AC4B3A, typelib=BA536135-308A-11D2-8E54-00A0C9AC4B3A )
 */
class AppFrame extends Frame
{
	public Applet m_App = null;

	public AppFrame(String title)
	{
		super(title);
	}
	
	public boolean handleEvent(Event evt)
	{
		if (evt.id == Event.WINDOW_DESTROY) {
			
			// since a browser would close the applet by calling stop and
			// destroy, we should also.
			m_App.stop();
			m_App.destroy();
			System.exit(0);
		}
		return super.handleEvent(evt);
	}
}


/////////////////////////////////////////////////////////////////////////
//  CLASS: DESTINATION_TYPE
//  DESCRIPTION:
//      C like structure to hold possible TAPI3 destination address type
/////////////////////////////////////////////////////////////////////////
/**
 * @com.register ( clsid=BA536138-308A-11D2-8E54-00A0C9AC4B3A, typelib=BA536135-308A-11D2-8E54-00A0C9AC4B3A )
 */
class DESTINATION_TYPE
{
	public String name;
	public int Tapi3Type;
}


/////////////////////////////////////////////////////////////////////////
//  CLASS: CallNot
//
//  PURPOSE: Supporting class to JT3Rec
//  DATE:    July 17, 1997 - March 30, 1998
//
//  DESCRIPTION:
//      Implements the ITCallNotification interface which is called
//      by TAPI 3.0 when incoming calls arrive.
//
/////////////////////////////////////////////////////////////////////////

class CallNot extends Object
      implements ITTAPIEventNotification,	// notification interface
                 TAPI_EVENT,				// CET_xxx constants
                 tapi3.CALL_STATE,				// CS_xxx constants
				 CALL_PRIVILEGE,			// CP_xxx constants
				 TapiConstants,				// misc. constants
				 tapi3.TERMINAL_DIRECTION,
				 PARTICIPANT_EVENT				 
{
    // Reference to main program object.
    private jt3call m_App = null;

    
    /////////////////////////////////////////////////////////////////////
    // Constructor
    /////////////////////////////////////////////////////////////////////
    public CallNot(jt3call app)
    {
        m_App = app;
    }

    /////////////////////////////////////////////////////////////////////
    // Event 
    //
    // The only method in the ITCallNotification interface.  This gets
    // called by TAPI 3.0 when there is a call event to report.
    //
    // It is important that you use the /X:m- switch when importing the
    // TAPI 3.0 typelib to Java using JActiveX.  This will turn off
    // auto-marshalling of variables passed from CallNot to JT3Rec.  If
    // you do not, the program will freeze whenever JT3Rec tries to use
    // a variable given to it by CallNot.
    /////////////////////////////////////////////////////////////////////
    public void Event( 
						int eventType,
						Object event
					 )
	{

		ITCallNotificationEvent pCallNotificationEvent;
		String Caption;
		int					CallEventType;
        Variant				avar;
        ITCollection		itc;
		ITCallInfo			pCallInfo;
		IVideoWindow		VideoWindow;
        tapi3.ITTerminal			aterm;
        tapi3.ITTerminal			pITTerminal;
		int					astr;
		int					vis;
		confmsp.ITSubStream 		pSubStream;
		confmsp.ITParticipantSubStreamControl pParticipantControl;
		try
		{
		switch(eventType)
		{
		case TE_CALLNOTIFICATION:
                pCallNotificationEvent = (ITCallNotificationEvent) event; 
				int cp;
				ITCallInfo		pCall;
				pCall=pCallNotificationEvent.getCall();
				cp=pCall.getPrivilege();
                if (cp==CP_MONITOR)
				{
                    // CP_MONITOR means that the application is being
                    // notified of a new call, and the application has monitor
                    // priveleges on that call.  event is the Call object.
                    // We should not get any CET_CALLMONITOR notifications in
                    // this application, since we only registered for owner in
                    // RegisterCallTypes.
				}
				else
				if (cp==CP_OWNER)
				{
                    // CP_OWNER means that the application is being notified
                    // of a call, and the application has owner privileges on
                    // that call.  event is the Call object.
                    // Note that we don't answer the call at this point.  The
                    // application should wait for a CS_OFFERING CallState
                    // message before answering the call.
					m_App.m_Call = (ITBasicCallControl) pCall;
                    m_App.SetStatusMessage("Incoming owner call");
				}
			break;
		case TE_CALLSTATE:
				// CET_CALLSTATEEVENT is a call state event.  
				// event is an ITCallStateEvent object.
				int cs;
	            ITCallStateEvent callStateEvent = (ITCallStateEvent) event;
				cs = callStateEvent.getState();
		        switch (cs)
			    {
					case CS_DISCONNECTED:
						System.out.println("EVENT5 call state disconnect");
						m_App.CleanUp();
						m_App.InitializeTAPI();

                    break;
					case CS_CONNECTED:
						System.out.println("EVENT7 call state connect");
						// make the in dynamic videos visible
                   break;   
				}			// of cs    
					break;
					
			case TE_CALLMEDIA:
				int evt;
	            ITCallMediaEvent callMediaEvent = (ITCallMediaEvent) event;
				evt = callMediaEvent.getEvent();
		        switch (evt)
		        {
		        	case CALL_MEDIA_EVENT.CME_STREAM_ACTIVE:
						tapi3.ITStream Strm=callMediaEvent.getStream();
		        		break;
		        }
				break;

			case TE_PRIVATE:
				break;
			} //main switch
		}
		catch(Exception e)
		{
			e.printStackTrace();
			System.out.println("keep going");
		}
	}

    /////////////////////////////////////////////////////////////////////
    // EnableVideoWindow 
    //
	// This function basically enables or disables a Video Window 
	// It checks if the substream has media type Video and the terminals
	// associated have media type render
    /////////////////////////////////////////////////////////////////////
	private void EnableVideoWindow(confmsp.ITSubStream pSubStream,String Caption,boolean bEnable)
	{
		Variant avar;
		ITCollection itc;
		IVideoWindow VideoWindow;
		if(pSubStream.getStream().getMediaType()==TAPIMEDIATYPE_VIDEO)		
		{
			avar=pSubStream.getTerminals();
			itc=(ITCollection)avar.toDispatch();
			System.out.println("MediaType is Video , #term ="+itc.getCount());
			for(int tCnt=1;tCnt<=itc.getCount();tCnt++)
			{
				avar=itc.getItem(tCnt);
				System.out.println("Terminal # "+tCnt);
				if(((tapi3.ITTerminal)(avar.toObject())).getDirection()==tapi3.TERMINAL_DIRECTION.TD_RENDER)
				{
					System.out.println("Video Window ,Name = " +Caption +" enable = "+ bEnable);
					
					VideoWindow=(IVideoWindow)((tapi3.ITTerminal)(avar.toObject()));
					if(bEnable)					
						VideoWindow.putAutoShow(-1);														
					else
						VideoWindow.putAutoShow(0);														
						
					VideoWindow.putCaption(Caption);		
				}
			}
		}

	}

	
}   // of class             



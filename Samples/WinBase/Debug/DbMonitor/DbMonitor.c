/*---------------------------------------------------------------------------
    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
    ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
    TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
    PARTICULAR PURPOSE

    Copyright (C) 1998 - 2000. Microsoft Corporation. All rights reserved.

	%%File: DBMONITOR.C
	%%Unit: dbmonitor

	Starts the process on the command line and monitors debug events
	generated by that process, sending them to stdout or an output file.
	Program terminates immediately after all the processes generated by the
	command line have terminated

----------------------------------------------------------------------------*/

#include <windows.h>
#include <winbase.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <wintrust.h>
#include <imagehlp.h>
#include <time.h>
#define PATCHSIZE 6
#define BUFF_SIZE 4096
#define SZBUFFSIZE 19
#define SECONDS_IN_DAY 86400
#define LILBUFFSIZE 15
#define CEXP 20
#define CTHREADS 2000 // if you get more than this...that's too many threads
#define CPROCESSES 100 // oh, you hope you don't get near this
#define CMODULES 2000
#define MAXSYMNAME 512
#define PESIG 0x00004550
#define CINSTRMNTS 2
#define INT3 0xCC
#define JMP 0xE9
#define NOOP 0x90
#define TRAPFLAG 0x00000100
#define THREAD_OP_FAIL 0xFFFFFFFF

/*
    Special Breakpoint resolution functions
*/
typedef void (*fpBPointExtra)(FILE *, DEBUG_EVENT *);
void fpLoadLibExAExtra(FILE *, DEBUG_EVENT *);
void fpLoadLibExWExtra(FILE *, DEBUG_EVENT *);

/*
    Enumeration for mode flags used to keep track of what behavior the user
	expects based on command line flags
*/
enum
{
	mdNone = 0x00,  // reporting event flags
	mdDll = 0x01,
	mdDMsg = 0x02,
	mdExp = 0x04,
	mdThread = 0x08,
	mdProc = 0x10,
	mdDefault = 0x03,

	mdLoadLib = 0x01000000, // flags for Import Breakpoint instrumentation
	mdInstrmnts = 0x01000000, // sun of Breakpoint instrmnt flags

	mdTimeStamp = 0x40000000, // print time elapsed
	mdOutput = 0x80000000,
	mdRepEvents = 0x0000001F, // sum of reporting event flags...
};

/*
	Enumeration for Process and Module flags
*/
enum
{
	fSymInit = 0x01,
	fStaticDone = 0x02,
};

/*
    Pairs for command line flag and the associated mode flag to set
*/
struct { char ch; DWORD md; } vrgmd[] =
{
	  {'d', mdDll},
	  {'m', mdDMsg},
	  {'x', mdExp},
	  {'t', mdThread},
	  {'p', mdProc},
	  {'l', mdLoadLib},
	  {'s', mdTimeStamp}, 
	  {'o', mdOutput}, 
      {'\0', mdNone}, // make sure this line is the last one
};


/*
	For the time stuff
*/
enum
{
	sigMSec = 1,
	sigSec,
	sigMin,
	sigHour,
	sigDay,
};

/*
	Pairs for breakpoint instrumentation

	IF YOU WISH TO ADD YOUR OWN EXPORT BREAKPOINTS just add lines to
	this array and update CINSTRMNTS

	The offset is the number of code bytes into the fxn at which the prolog
	will have completed executing, thereby ensuring that the stackframe is
	in a state that ImageHlp can handle it w/o problems
*/
struct { char *sz; DWORD md; char *szModule; int offset; fpBPointExtra fp; } 
vrgimp[CINSTRMNTS] =
{
	{"LoadLibraryExW", mdLoadLib, "KERNEL32.DLL", 9, fpLoadLibExWExtra},
	{"LoadLibraryExA", mdLoadLib, "KERNEL32.DLL", 6, fpLoadLibExAExtra},
};

/*
	All known exception types, as of January 1998 MSDN 
*/
struct {DWORD dwExpCode; char * szExp; } vrgexp[CEXP] =
{
	{EXCEPTION_ACCESS_VIOLATION, "ACCESS_VIOLATION"}, 
	{EXCEPTION_ARRAY_BOUNDS_EXCEEDED, "ARRAY_BOUNDS_EXCEEDED"},
	{EXCEPTION_BREAKPOINT, "BREAKPOINT"}, 
	{EXCEPTION_DATATYPE_MISALIGNMENT, "DATATYPE_MISALIGNMENT"},  
	{EXCEPTION_FLT_DENORMAL_OPERAND, "FLT_DENORMAL_OPERAND"},  
	{EXCEPTION_FLT_DIVIDE_BY_ZERO, "FLT_DIVIDE_BY_ZERO"},  
	{EXCEPTION_FLT_INEXACT_RESULT, "FLT_INEXACT_RESULT"},  
	{EXCEPTION_FLT_INVALID_OPERATION, "FLT_INVALID_OPERATION"} , 
	{EXCEPTION_FLT_OVERFLOW, "FLT_OVERFLOW"},  
	{EXCEPTION_FLT_STACK_CHECK, "FLT_STACK_CHECK"},  
	{EXCEPTION_FLT_UNDERFLOW, "FLT_UNDERFLOW"},  
	{EXCEPTION_ILLEGAL_INSTRUCTION, "ILLEGAL_INSTRUCTION"},  
	{EXCEPTION_IN_PAGE_ERROR, "IN_PAGE_ERROR"},  
	{EXCEPTION_INT_DIVIDE_BY_ZERO, "INT_DIVIDE_BY_ZERO"},  
	{EXCEPTION_INT_OVERFLOW, "INT_OVERFLOW"},  
	{EXCEPTION_INVALID_DISPOSITION, "INVALID_DISPOSITION"},  
	{EXCEPTION_NONCONTINUABLE_EXCEPTION, "NONCONTINUABLE_EXCEPTION"},  
	{EXCEPTION_PRIV_INSTRUCTION, "PRIV_INSTRUCTION"},  
	{EXCEPTION_SINGLE_STEP, "SINGLE_STEP"},  
	{EXCEPTION_STACK_OVERFLOW, "STACK_OVERFLOW"}
};  

/*
	We want to always use the same Thread and Process Handles, so we hang
	onto them.  We also need to keep track of all our module bases.
*/
typedef struct _Thread
{
	DWORD dwThreadId;
	HANDLE hThread;
} Thread;

typedef struct _Proc
{
	DWORD dwProcessId;
	HANDLE hProc;
	DWORD dwFlags;
	DWORD dwBase;
	DWORD dwSingleStepAddr;

	BYTE rgbInstr[CINSTRMNTS];
	DWORD rgdwInstrmnt[CINSTRMNTS];  // points for Breakpoint Instrumentation
} Proc;

typedef struct _Module
{
	DWORD dwModuleBase;
	DWORD dwProcessId;
	DWORD dwFlags;
	char *szModName;
} Module;

/* globals */
DWORD vmd;
char vszUnkExp[] = "UNKNOWN EXCEPTION!!!!\n";
Thread vrgTh[CTHREADS];
Proc vrgProc[CPROCESSES];
Module vrgModule[CMODULES];
int vcThread;
int vcProc;
int vcModule;
int fPsapiEnsured;
SYSTEMTIME vsystimeStart;
time_t vtime_tStart;
						
/* Prototypes */
void upcase(char *);
int iThIdCmp(const void *, const void *);
void RemoveThread(DWORD);
void AddThread(DWORD, HANDLE);
void AddProc(FILE *, DWORD, DWORD, HANDLE);
void RemoveProc(DWORD);
Proc* pGetpProc(DWORD);
int bGetProcHandle(DWORD, HANDLE *);
int bSymInitialized(FILE *, HANDLE *, DWORD);
void AddModule(FILE *, DWORD, DWORD);
void RemoveModule(FILE *, DWORD, DWORD);
void AddModuleName(DWORD, DWORD, char *);
int iGetModuleGuessIndex(DWORD, DWORD);
Module* pGetpModule(DWORD, DWORD);
void Patch(FILE *, Proc *, int, IMAGE_EXPORT_DIRECTORY*, DWORD, DWORD);
void HookImage(FILE *, DWORD, DWORD);
void PatchModule(FILE *, DWORD, DWORD);
void PatchAllModules(FILE *, DWORD);
void ParseArgs(char *);
void PrintUsage(void);
void PrintContext(FILE *, CONTEXT *);
void StackTrace(FILE *, DEBUG_EVENT *);
void InstrmntStackTrace(FILE *, Proc *, DEBUG_EVENT *);
void GetModuleNameByExport(char *, FILE *, DWORD, DWORD);
void PrintTimeStamp(FILE *, BOOL);

/*
	Learn and output the string passed to LoadLibraryExA
*/ 
void fpLoadLibExAExtra(FILE *fp, DEBUG_EVENT *pde)
{
	HANDLE hProc;
	HANDLE hThread;
	Thread Th;
	Thread *pTh;
	CONTEXT context;
	DWORD dwSz;
	DWORD dw;
	char sz[MAX_PATH + 1];
	int k;
	char ch;

	if (!bGetProcHandle(pde->dwProcessId, &hProc))
		return;
	
	Th.dwThreadId = pde->dwThreadId;
	pTh = (Thread *) bsearch(&Th, vrgTh, vcThread,
							   sizeof(Thread), iThIdCmp);

	if (pTh == NULL)
		return;

	hThread = pTh->hThread;

	memset(sz, 0, (MAX_PATH + 1) * sizeof(char));
	memset(&context, 0, sizeof(CONTEXT));
	context.ContextFlags = CONTEXT_FULL;

	// so, apparently we need to init this for the first case, joy
		if (!GetThreadContext(hThread, &context))
		{
		// well, we didn't even get off the ground
		dw = GetLastError();
		return;
		}

	if (!ReadProcessMemory(hProc, 
						   (VOID *) (context.Ebp + 8), 
						   &dwSz,
						   sizeof(DWORD),
						   NULL))
		{
		dw = GetLastError();
		return;
		}
	
	// now we're ready to read the string in
	k = 0;
	do 
		{
		if (!ReadProcessMemory(hProc,
							   (VOID *) (dwSz), 
							   &ch,
							   sizeof(char),
							   NULL))
			{
			ch = (char) 0;
			}
		sz[k] = ch;
		k++;
		dwSz += sizeof(char);
		} while (ch != (char) 0 && k < MAX_PATH); // done
	if (k != 0)
		{
		sz[MAX_PATH] = (char) 0;
		fprintf(fp, "\nBREAKPOINT: LoadLibraryExA(%s)\n", sz);
		}
	return;
}


/*
	Learn and output the string passed to LoadLibraryExW
*/ 
void fpLoadLibExWExtra(FILE *fp, DEBUG_EVENT *pde)
{
	HANDLE hProc;
	HANDLE hThread;
	Thread Th;
	Thread *pTh;
	CONTEXT context;
	DWORD dwWz;
	DWORD dw;
	WCHAR wz[MAX_PATH + 1];
	int k;
	WCHAR wch;

	if (!bGetProcHandle(pde->dwProcessId, &hProc))
		return;
	
	Th.dwThreadId = pde->dwThreadId;
	pTh = (Thread *) bsearch(&Th, vrgTh, vcThread,
							   sizeof(Thread), iThIdCmp);

	if (pTh == NULL)
		return;

	hThread = pTh->hThread;

	memset(wz, 0, (MAX_PATH + 1) * sizeof(WCHAR));
	memset(&context, 0, sizeof(CONTEXT));
	context.ContextFlags = CONTEXT_FULL;

	// so, apparently we need to init this for the first case
	if (!GetThreadContext(hThread, &context))
		{
		// well, we didn't even get off the ground
		dw = GetLastError();
		return;
		}

	if (!ReadProcessMemory(hProc, 
						   (VOID *) (context.Ebp + 8), 
						   &dwWz,
						   sizeof(DWORD),
						   NULL))
		{
		dw = GetLastError();
		return;
		}
	
	// now we're ready to read the string in
	k = 0;
	do 
		{
		if (!ReadProcessMemory(hProc,
							   (VOID *) (dwWz), 
							   &wch,
							   sizeof(WCHAR),
							   NULL))
			{
			wch = (WCHAR) 0;
			}
		wz[k] = wch;
		k++;
		dwWz+=2;
		} while (wch != (WCHAR) 0 && k < MAX_PATH); // done
	if (k != 0)
		{
		wz[MAX_PATH] = (WCHAR) 0;
		fprintf(fp, "\nBREAKPOINT: LoadLibraryExW(%S)\n", wz);
		}
	return;
}


/*
	Upcase a string in place
*/
void upcase(char *ch)
{
	while (*ch != '\0')
		{
		*ch = toupper(*ch);
		ch++;
		}
}


/*
	Comparison routine used by bsearch/qsort.  Given pointers to two Thread
	structures, will return based on standard assending sort order of the
	dwThreadId.
*/
int iThIdCmp(const void * pTh1, const void * pTh2)
{
	if (  ((Thread *) pTh1)->dwThreadId <  
			((Thread *) pTh2)->dwThreadId ) 
		return -1;
	if (  ((Thread *) pTh1)->dwThreadId >  
		((Thread *) pTh2)->dwThreadId ) 
		return 1;
	return 0;
}	


/* 
	Throws a thread out of the global data structure, w/ appropriate clean up
*/
void RemoveThread(DWORD dwThreadId)
{
	Thread Th;
	Thread *pTh;

	Th.dwThreadId = dwThreadId;

	pTh = (Thread *) bsearch(&Th, vrgTh, vcThread,
								   sizeof(Thread), iThIdCmp);
	if (pTh == NULL)
		return;
	// now leave the array in a valid state
	CloseHandle(pTh->hThread);
	vcThread--;
	*pTh = vrgTh[vcThread];
	qsort(vrgTh, vcThread, sizeof(Thread), iThIdCmp);
}


/*
	Makes a copy of the hThread with appropriate usage permissions and stores
	it in the global data structure.  This is necessary as the original Thread
	handle becomes invalid after the conclusion of the WaitForDebugEvent in
	which it is provided
*/
void AddThread(DWORD dwThreadId, HANDLE hThread)
{
	if (vcThread >= CTHREADS)
		return;

	vrgTh[vcThread].dwThreadId = dwThreadId;
	if (!DuplicateHandle(GetCurrentProcess(),
						 hThread,
						 GetCurrentProcess(),
						 &(vrgTh[vcThread].hThread),
						 THREAD_GET_CONTEXT | THREAD_SET_CONTEXT,
						 FALSE,
						 0))
		{
		dwThreadId = GetLastError();
		}
	vcThread++;
	// for fast lookup...this is a waste if you only have ten threads...
	// but you get thirty going and well, this will help
	qsort(vrgTh, vcThread, sizeof(Thread), iThIdCmp);
}


/*
	Makes a copy of the hProcess with appropriate usage permissions and stores
	it in the global data structure.  This is necessary as the original Process
	handle becomes invalid after the conclusion of the WaitForDebugEvent in
	which it is provided
*/
void AddProc(FILE *fp, DWORD dwProcessId, DWORD dwBase, HANDLE hProc)
{
	if (vcProc >= CPROCESSES)
		{
		fprintf(fp, "Too many child processes\n");
		return;
		}
	vrgProc[vcProc].dwProcessId = dwProcessId;
	vrgProc[vcProc].dwBase = dwBase;
	vrgProc[vcProc].dwFlags = 0x00000000;
	if (!DuplicateHandle(GetCurrentProcess(),
						 hProc,
						 GetCurrentProcess(),
						 &(vrgProc[vcProc].hProc),
						 PROCESS_ALL_ACCESS, 
						 FALSE,
						 0))
		{
		dwProcessId = GetLastError();
		}
	vcProc++;
}


/*
	Removed a Process entry from the global data structure and does appropriate
	cleanup.
*/
void RemoveProc(DWORD dwProcessId)
{
	int i;


	for (i = 0; i < vcProc; i++)
		{
		if (vrgProc[i].dwProcessId == dwProcessId)
			{
			CloseHandle(vrgProc[i].hProc);
			vrgProc[i] = vrgProc[vcProc - 1];
			break;
			}
		}
	vcProc--;
	return;
}


/*
	Returns a pointer to the Process structure for the given process id
*/
Proc *pGetpProc(DWORD id)
{
	Proc *pProc = NULL;
	int i;

	for (i = 0; i < vcProc; i++)
		{
		if (vrgProc[i].dwProcessId == id)
			{
			pProc = vrgProc + i;
			i = vcProc;
			}
		}
	return pProc;

}


/*
	Sets the pointed address to the requested handle, returns false if the
	handle could not be found.
*/
int bGetProcHandle(DWORD dwProcessId, HANDLE *phProc)
{
	int i;

	for (i = 0; i < vcProc; i++)
		{
		if (vrgProc[i].dwProcessId == dwProcessId)
			{
			*phProc = vrgProc[i].hProc;
			return TRUE;
			}
		}
	return FALSE;
}

/*
	Keeps track of which modules have had their symbols initalizaed, and will
	attempt on-demand initialization.  Necessary as "invasive" symbol init.
	of an entire process at process create time will fail
*/
int bSymInitialized(FILE *fp, HANDLE *phProc, DWORD dwProcessId)
{
	int i;
	DWORD dw;
	API_VERSION api;

	api = *ImagehlpApiVersion();
										  
	for (i = 0; i < vcProc; i++)
		{
		if (vrgProc[i].dwProcessId == dwProcessId)
			{
			*phProc = vrgProc[i].hProc;
			if (vrgProc[i].dwFlags & fSymInit)
				return TRUE;
			else
				{
				if (SymInitialize(*phProc, NULL, FALSE)) //invasive doesn't work
					{
					vrgProc[i].dwFlags |= fSymInit;
					return TRUE;
					}
				dw = GetLastError();
				fprintf(fp, "Can't initalize Symbols for Process %d Err:\n", 
						dwProcessId);
				return FALSE;
				}
			}
		}
	return FALSE;
}


/* 
	Adds a new ProcessId/Module pair to the global array, and does any
	additional Module patching that may be required
*/
void AddModule(FILE *fp, DWORD dwProcessId, DWORD dwBase)
{
	Proc *pProc;
	int i;
	
	if (vcModule >= CMODULES)
		{
		fprintf(fp, "Reached Module limit!\n");
		return;
		}
	vrgModule[vcModule].dwModuleBase = dwBase;
	vrgModule[vcModule].dwProcessId = dwProcessId;
	vcModule++;

	pProc = pGetpProc(dwProcessId);
	if (!(pProc->dwFlags & fStaticDone))
		return;
	
	// loop through and repatch all the modules
	for (i = 0; i < vcModule; i++)
		if (vrgModule[i].dwProcessId == dwProcessId)
		PatchModule(fp, dwProcessId, vrgModule[i].dwModuleBase);
	return;
}


/* 
	Removes a ProcessId/Module pair from the global array
*/
void RemoveModule(FILE *fp, DWORD dwProcessId, DWORD dwBase)
{
	int i;

	for (i = 0; i < vcModule; i++)
		{
		if (vrgModule[i].dwModuleBase == dwBase 
			&& vrgModule[i].dwProcessId == dwProcessId)
			{
			// free the string
			if (vrgModule[i].szModName != NULL)
				free(vrgModule[i].szModName);

			// copy last over (if needed) and decrement global counter
			if (i < (vcModule - 1))
				memcpy(vrgModule + i, vrgModule + vcModule - 1, sizeof(Module));
			vcModule--;
			i = vcModule; // break out of loop
			}
		}
}


/*
	Adds the string containing the module name to a given module base/proc id
	pair in the global module array
*/
void AddModuleName(DWORD dwProcessId, DWORD dwBase, char *sz)
{
	int i;
	char *szHeap;

	for (i = 0; i < vcModule; i++)
		{
		if (vrgModule[i].dwProcessId == dwProcessId
			&& vrgModule[i].dwModuleBase == dwBase)
			{
			szHeap = (char *) malloc(strlen(sz) + 1);
			strcpy(szHeap, sz);
			vrgModule[i].szModName = szHeap;
			i = vcModule;
			}
		}
}


/*
	Attempts to resolve the index into the global module array for the
	module in which a given address is contained within the given process's
	address space
*/
int iGetModuleGuessIndex(DWORD dwAddress, DWORD dwProcessId)
{
	int i;
	int iGuess;

	iGuess = -1;
	for (i = 0; i < vcModule; i++)
		{
		if (vrgModule[i].dwProcessId == dwProcessId)
			{
			if (vrgModule[i].dwModuleBase > dwAddress)
				continue;
			else if (iGuess == -1)
				{
				iGuess = i;
				}
			else if (vrgModule[i].dwModuleBase > vrgModule[iGuess].dwModuleBase)
				iGuess = i;
			}
		}
	return iGuess;
}


/*
	Returns a pointer to a Module stucture within the global module array
*/
Module* pGetpModule(DWORD dwProcessId, DWORD dwBase)
{
	int i;

	for (i = 0; i < vcModule; i++)
		{
		if (vrgModule[i].dwProcessId == dwProcessId
			&& vrgModule[i].dwModuleBase == dwBase)
			{
			return &(vrgModule[i]);
			}
		}
	return NULL;
}


/*
	This function will patch a particular entry in the Import Address Table
	and update the patch table for the process with the bound value
*/
void Patch(FILE * fp, Proc *pProc, int iVRGIMPindex, 
		   IMAGE_EXPORT_DIRECTORY *pied, DWORD dwExpIndex, DWORD dwBase)
{
	DWORD dwOffset; // offset of this import into the export address table
	DWORD RealThunk;
	BYTE bInstr;

	if (pProc->rgdwInstrmnt[iVRGIMPindex] != 0)
		return;

	dwOffset = dwExpIndex * 4;
	if (!ReadProcessMemory(pProc->hProc,
						   (VOID *) (dwBase + (DWORD) pied->AddressOfFunctions + dwOffset),
						   &RealThunk,
						   sizeof(DWORD),
						   NULL))
		{
		dwOffset = GetLastError(); // double duty for dwOffset
		goto NO_PATCH;
		}
	if (RealThunk == 0)
		return;
	RealThunk +=dwBase;
	RealThunk += vrgimp[iVRGIMPindex].offset;
	if (!ReadProcessMemory(pProc->hProc,
						   (VOID *) (RealThunk),
						   &bInstr,
						   sizeof(BYTE),
						   NULL))
		{
		goto NO_PATCH;
		}
	pProc->rgbInstr[iVRGIMPindex] = bInstr;
	bInstr = INT3; 
	if (!WriteProcessMemory(pProc->hProc,
							(VOID *) (RealThunk),
							&bInstr,
							sizeof(BYTE),
							NULL))
		{
		goto NO_PATCH;
		}
	pProc->rgdwInstrmnt[iVRGIMPindex] = RealThunk;

	return;
NO_PATCH:
	fprintf(fp, "Can not patch export %s for image at base 0x%X\n",
			vrgimp[iVRGIMPindex].sz, dwBase);
}


/*
	If the loader doesn't provide us with the Module's name, we attempt to get
	the name that the module calls itself in its Export Table, returning the
	empty string if none is found
*/
void GetModuleNameByExport(char *szOut, FILE *fp, DWORD dwProcessId, DWORD dwBase)
{
	IMAGE_OPTIONAL_HEADER ioh;
	IMAGE_DATA_DIRECTORY iddExportTable;
	IMAGE_EXPORT_DIRECTORY ied;
	WORD rgwCoffHdr[10];
	BYTE rgbBuff[LILBUFFSIZE];
	Proc *pProc;
	HANDLE hProc;
	DWORD rvaPESig; // virtual relative address
	DWORD sig;
	DWORD dw;
	WORD cSections;
	WORD wIOHSize;
			
	memset(szOut, 0, LILBUFFSIZE);

	pProc = pGetpProc(dwProcessId);
	if (pProc == NULL)
		{
		return;
		}

	hProc = pProc->hProc;
	memset(&iddExportTable, 0, sizeof(IMAGE_DATA_DIRECTORY));
	memset(&ioh, 0, sizeof(IMAGE_OPTIONAL_HEADER));
	memset(&ied, 0, sizeof(IMAGE_EXPORT_DIRECTORY));
	// imagehlp isn't particularly useful for going cross process so we do it
	// by hand
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + 0x3c), // offset to *PE signature
						   &rvaPESig,
						   sizeof(DWORD),
						   NULL))
		{
		// well, we can't read this process image
		dw = GetLastError();
//		fprintf(fp, "Can't read file header for image base 0x%X!\n", dwBase);
		return;
		}
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + rvaPESig), 
						   &sig,
						   sizeof(DWORD),
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Can't read signature for image base 0x%X!\n", dwBase);
		return;
		}
	if (sig != PESIG)
		{
		// this isn't a portable executable!
		fprintf(fp, "Loaded non portable executable at base 0x%X!\n", dwBase);
		return;
		}
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + rvaPESig + 0x4), // offset to COFF
						   rgwCoffHdr,
						   sizeof(WORD) * 10, // size of COFF header
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Can't read COFF HEADER for image base 0x%X!\n", dwBase);
		return;
		}
	cSections = rgwCoffHdr[1];
	wIOHSize = rgwCoffHdr[8];
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + 0x18 + rvaPESig), // offset to optional header
						   &ioh,
						   sizeof(IMAGE_OPTIONAL_HEADER),
						   NULL))
		{
		// well, we can't read this process image
		dw = GetLastError();
		fprintf(fp, "Can't read optional header for image base 0x%X!\n", dwBase);
		return;
		}

	if (ioh.NumberOfRvaAndSizes == 0)
		return;
	

	if (!ReadProcessMemory(hProc,
						   (VOID *) (dwBase + rvaPESig + 0x78),
						   &iddExportTable,
						   sizeof(IMAGE_DATA_DIRECTORY),
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Warning!  Can not read export data dir!\n");
		goto OUT_OF_PATCHING;
		}
		// get the export directory table
	if (!ReadProcessMemory(hProc,
						   (VOID *) (dwBase + iddExportTable.VirtualAddress),
						   &ied,
						   sizeof(IMAGE_EXPORT_DIRECTORY),
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Warning!  Can not read export table!\n");
		goto OUT_OF_PATCHING;
		}
	
	// get the export DLL name
	if (ied.Name == 0) // an RVA
		return;
	if (!ReadProcessMemory(hProc,
						   (VOID *) (dwBase + ied.Name),
						   rgbBuff,
						   LILBUFFSIZE,
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Warning!  Can not read export table!\n");
		goto OUT_OF_PATCHING;
		}
	rgbBuff[LILBUFFSIZE - 1] = 0;
	strcpy(szOut, (char *) rgbBuff);
OUT_OF_PATCHING:
	return;
}


/*
	This function will patch the exports of the module, if there are any
*/
void PatchModule(FILE *fp, DWORD dwProcessId, DWORD dwBase)
{
	IMAGE_OPTIONAL_HEADER ioh;
	IMAGE_DATA_DIRECTORY iddExportTable;
	IMAGE_EXPORT_DIRECTORY ied;
	WORD rgwCoffHdr[10];
	BYTE rgbBuff[LILBUFFSIZE];
	Proc *pProc;
	HANDLE hProc;
	DWORD rvaPESig; // virtual relative address
	DWORD sig;
	DWORD rvaFxnName;
	DWORD rvaFxnNameTable;
	DWORD dw;
	DWORD dwExpIndex;
	WORD cSections;
	WORD wIOHSize;
	char ch;
	int j;
	int k;
			
	pProc = pGetpProc(dwProcessId);
	if (pProc == NULL)
		{
		return;
		}

	hProc = pProc->hProc;
	memset(&iddExportTable, 0, sizeof(IMAGE_DATA_DIRECTORY));
	memset(&ioh, 0, sizeof(IMAGE_OPTIONAL_HEADER));
	memset(&ied, 0, sizeof(IMAGE_EXPORT_DIRECTORY));
	// imagehlp isn't particularly useful for going cross process so we do it
	// by hand
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + 0x3c), // offset to *PE signature
						   &rvaPESig,
						   sizeof(DWORD),
						   NULL))
		{
		// well, we can't read this process image
		dw = GetLastError();
		return;
		}
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + rvaPESig), 
						   &sig,
						   sizeof(DWORD),
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Can't read signature for image base 0x%X!\n", dwBase);
		return;
		}
	if (sig != PESIG)
		{
		// this isn't a portable executable!
		fprintf(fp, "Loaded non portable executable at base 0x%X!\n", dwBase);
		return;
		}
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + rvaPESig + 0x4), // offset to COFF
						   rgwCoffHdr,
						   sizeof(WORD) * 10, // size of COFF header
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Can't read COFF HEADER for image base 0x%X!\n", dwBase);
		return;
		}
	cSections = rgwCoffHdr[1];
	wIOHSize = rgwCoffHdr[8];
	if (!ReadProcessMemory(hProc, 
						   (VOID *) (dwBase + 0x18 + rvaPESig), // offset to optional header
						   &ioh,
						   sizeof(IMAGE_OPTIONAL_HEADER),
						   NULL))
		{
		// well, we can't read this process image
		dw = GetLastError();
		fprintf(fp, "Can't read optional header for image base 0x%X!\n", dwBase);
		return;
		}

	if (ioh.NumberOfRvaAndSizes == 0)
		return;
	

	if (!ReadProcessMemory(hProc,
						   (VOID *) (dwBase + rvaPESig + 0x78),
						   &iddExportTable,
						   sizeof(IMAGE_DATA_DIRECTORY),
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Warning!  Can not read export data dir!\n");
		goto OUT_OF_PATCHING;
		}
		// get the export directory table
	if (!ReadProcessMemory(hProc,
						   (VOID *) (dwBase + iddExportTable.VirtualAddress),
						   &ied,
						   sizeof(IMAGE_EXPORT_DIRECTORY),
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Warning!  Can not read export table!\n");
		goto OUT_OF_PATCHING;
		}
	
	// get the export DLL name
	if (ied.Name == 0) // an RVA
		return;
	if (!ReadProcessMemory(hProc,
						   (VOID *) (dwBase + ied.Name),
						   rgbBuff,
						   LILBUFFSIZE,
						   NULL))
		{
		dw = GetLastError();
		fprintf(fp, "Warning!  Can not read export table!\n");
		goto OUT_OF_PATCHING;
		}
	
	rvaFxnNameTable = (DWORD) ied.AddressOfNames;
	if (rvaFxnNameTable == 0)
		return;

	upcase((char *) rgbBuff);

	// now loop through vrgimp looking for module matches
	for (j = 0; j < CINSTRMNTS; j++)
		{
		if (strcmp((char *) rgbBuff, vrgimp[j].szModule))
			continue;

		// ok, we found a live one...time to look for the fxn to patch
		for (dwExpIndex = 0; dwExpIndex < (DWORD) ied.NumberOfNames; dwExpIndex++)
			{
			if (!ReadProcessMemory(hProc,
								   (VOID *) (dwBase + rvaFxnNameTable + 
											 (dwExpIndex * 4)), 
								   &rvaFxnName,
								   sizeof(DWORD),
								   NULL))
				{
				dw = GetLastError();
				continue;
				}
			// now we loop through the characters in the Fxn Name
			k = 0;
			do 
				{
				if (ReadProcessMemory(hProc,
									  (VOID *) (dwBase + rvaFxnName), 
									  &ch,
									  1,
									  NULL))
					{
					if (vrgimp[j].sz[k] == ch)
						{
						if (ch == 0)
							Patch(fp, pProc, j, &ied, dwExpIndex, dwBase);
						else
							{
							k++;
							rvaFxnName++;
							}
						}
					else
						ch = 0; // character mismatch, not the right string
					}
				else
					ch = 0;	// we couldn't read the memory
				} while (ch != 0); // done with this FxnName
			} // close for loop over the FxnNamePointer table
		} // close for loop over the vrgimp entries
		
OUT_OF_PATCHING:
	return;
}


/*
	Patches all currently loaded modules in the process
*/
void PatchAllModules(FILE *fp, DWORD dwProcessId)
{
	int i;
	
	if ((vmd & mdInstrmnts) == 0)
		return;

	// ok...loop through and patch all the modules
	for (i = 0; i < vcModule; i++)
		if (vrgModule[i].dwProcessId == dwProcessId)
		PatchModule(fp, dwProcessId, vrgModule[i].dwModuleBase);
	return;
}


/*
	Parses the command line flag list, setting mode flags appropriately
*/ 
void ParseArgs(char *pch)
{
	int i;

	while (*pch != '\0')
		{
		for (i = 0; vrgmd[i].ch != 0; i++)
			if (vrgmd[i].ch == *pch)
				vmd |= vrgmd[i].md;
		pch++;
		}
	return;
}


/*
	Prints Usage
*/
void PrintUsage(void)
{
	printf(
	"Debug Monitoring Tool (thin wrapper version)\n"
	"\n"
	"dbmonitor [-dmxplt] <command line to monitor>\n"
	"dbmonitor [-dmxplto] <outputfile> <command line to monitor>\n"
	"\n"
	"\tEvent Reporting Options\n"
	"\t\td will enable DLL load reporting\n"
	"\t\tm will enable Debug Message reporting\n"
	"\t\tx will enable Exception reporting\n"
	"\t\tp will enable Process creation/deletion reporting\n"
	"\t\tt will enable Thread creation/deletion reporting\n"
	"\tExport Breakpoint Instrumentation Options\n"
	"\t\tl will enable breakpointing of LoadLibrary calls\n" 
	"\tOutput Options\n"
	"\t\to will direct output to file given as next argument\n"
	"\t\ts will print time elapsed from process creation for each event\n"
	"\tDefault is to enable 'd' and 'm' reporting, printing to stdout\n"
	"\tSpecial Case:  if you specify 'o' without any reporting options\n"
	"\t               you get the default 'd' and 'm'\n"
	"\n"
	"Command will start up a process with the provided command line as a\n"
	"debugee, and report back on specific activities performed by the\n"
	"debugee.  If you have specified any import patching, you will get\n"
	"stack traces of those breakpoints.\n"
	"\n"
	);
	return;
}


/*
	Prints the time since debuggee process creation and follows with a newline
	if fNewLine is TRUE
*/
void PrintTimeStamp(FILE *fp, BOOL fNewLine)
{
	SYSTEMTIME systimeCurr;
	time_t time_tCurr;
	WORD wMSec;
	WORD wSec;
	WORD wMin;
	WORD wHour;
	DWORD dwDay;
	char szBuff[SZBUFFSIZE];
	int iSig;
	int iStart;

	if (vmd & mdTimeStamp)
		{
		GetSystemTime(&systimeCurr);
		time(&time_tCurr);
		iSig = 0;
		iStart = 18;
		     
		wHour = systimeCurr.wHour - vsystimeStart.wHour;
		wMin = systimeCurr.wMinute - vsystimeStart.wMinute;
		wSec = systimeCurr.wSecond - vsystimeStart.wSecond;
		wMSec = systimeCurr.wMilliseconds - vsystimeStart.wMilliseconds;
		
		// ok, now we do the carries...
		if (wMSec < 0)
			{
			wMSec += 1000;
			wSec--;
			}
		wMSec %= 1000; // just to be paranoid
		if (wSec < 0)
			{
			wSec += 60;
			wMin--;
			}
		wSec %= 60; // just to be paranoid
		if (wMin < 0)
			{
			wMin += 60;
			wHour--;
			}
		wMin %= 60; // just to be paranoid
		if (wHour < 0)
			{
			wHour += 24;
			}
		wHour %= 24; // just to be paranoid
		
		dwDay = (DWORD) (difftime(time_tCurr, vtime_tStart) / SECONDS_IN_DAY);
		
		if (dwDay)
			iSig = sigDay;
		else if (wHour)
			iSig = sigHour;
		else if (wMin)
			iSig = sigMin;
		else if (wSec)
			iSig = sigSec;
		else if (wMSec)
			iSig = sigMSec;

		memset(szBuff, 0, SZBUFFSIZE);
		switch (iSig)
			{
			case sigDay:
				iStart -= 6;
				sprintf(szBuff, "%5ud", dwDay);
				// fall through
			case sigHour:
				iStart -= 3;
				sprintf(&szBuff[6], "%.2d:", wHour);
				// fall through
			case sigMin:
				iStart -= 3;
				sprintf(&szBuff[9], "%.2d:", wMin);
				// fall through		
			case sigSec:
				iStart -= 2;
				sprintf(&szBuff[12], "%.2d", wSec);
				// fall through	
			case sigMSec:
				iStart -= 4;
				sprintf(&szBuff[14], ".%.3d", wMSec);
				break;
			default:
				iStart = 0;
				sprintf(szBuff, "0");
			}
		fprintf(fp, " TE %s", &szBuff[iStart]);
		}
		
	if (fNewLine)
		fprintf(fp, "\n");
}


/*
	Prints relevant fields of the thread context structure
*/
void PrintContext(FILE *fp, CONTEXT *pContext)
{
	fprintf(fp, "Context: EDI: 0x%08x  ESI: 0x%08x\n"
			"EAX: 0x%08x  EBX: 0x%08x  ECX: 0x%08x  EDX: 0x%08x\n"
			"EIP: 0x%08x  EBP: 0x%08x  SegCs: 0x%08x  EFlags: 0x%08x\n"
			"ESP: 0x%08x  SegSs: 0x%08x\n",
			pContext->Edi,
			pContext->Esi,
			pContext->Eax,
			pContext->Ebx,
			pContext->Ecx,
			pContext->Edx,
			pContext->Eip,
			pContext->Ebp,
			pContext->SegCs,
			pContext->EFlags,
			pContext->Esp,
			pContext->SegSs);
}


/*
	Called by every debug event, will print the current stack to the output
	file if the stack trace mode flag is set
*/
void StackTrace(FILE *fp, DEBUG_EVENT *pde)
{
	HANDLE hProc;
	HANDLE hThread;
	STACKFRAME sf;
	Thread Th;
	Thread *pTh;
	BYTE bBuff[ sizeof(IMAGEHLP_SYMBOL) + MAXSYMNAME ];
	CONTEXT context;
	PIMAGEHLP_SYMBOL pSym;
	DWORD dwSymOff;
	DWORD dw;
	int iModuleIndex;

	if (!bSymInitialized(fp, &hProc, pde->dwProcessId))
		return;

	Th.dwThreadId = pde->dwThreadId;
	pTh = (Thread *) bsearch(&Th, vrgTh, vcThread,
							   sizeof(Thread), iThIdCmp);

	if (pTh == NULL)
		return;

	hThread = pTh->hThread;

	memset(&sf, 0, sizeof(STACKFRAME));
	memset(&context, 0, sizeof(CONTEXT));
	context.ContextFlags = CONTEXT_FULL;

	// so, apparently we need to init this for the first case, joy
	if (!GetThreadContext(hThread, &context))
		{
		// well, we didn't even get off the ground
		dw = GetLastError();
		return;
		}

	sf.AddrPC.Offset = context.Eip;
	sf.AddrPC.Mode   = AddrModeFlat;  // we hope
	sf.AddrStack.Offset = context.Esp;
	sf.AddrStack.Mode   = AddrModeFlat;
	sf.AddrFrame.Offset = context.Ebp;
	sf.AddrFrame.Mode   = AddrModeFlat;

	// and now we can bother to link the pointer to the buffer and init
	pSym = (PIMAGEHLP_SYMBOL) bBuff;
	pSym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL) + MAXSYMNAME;
	pSym->MaxNameLength = MAXSYMNAME;

	while (1)
		{

		if ( !StackWalk(IMAGE_FILE_MACHINE_I386,
						hProc,
						hThread,
						&sf,
						&context,
						NULL,
						SymFunctionTableAccess,
						SymGetModuleBase,
						NULL))
			{
			dwSymOff = GetLastError();
			break;
			}
		
		dwSymOff = 0;
		
		iModuleIndex = iGetModuleGuessIndex(sf.AddrPC.Offset, pde->dwProcessId);
		
		if (SymGetSymFromAddr(hProc, sf.AddrPC.Offset, &dwSymOff, pSym))
			{
			fprintf(fp, "  %s+0x%X\t", pSym->Name, dwSymOff);
			if (iModuleIndex != -1)
				fprintf(fp,"Module: %s\n",vrgModule[iModuleIndex].szModName);
			else
				fprintf(fp, "\n");
			}
		else
			{
			dw = GetLastError();
			fprintf(fp, "  Can't resolve stack frame");
			if (iModuleIndex != -1)
				fprintf(fp,"  Module: %s\n",vrgModule[iModuleIndex].szModName);
			else
				fprintf(fp, "\n");
			continue;
			}
		}
}


/*
	Determine with import triggered the breakpoint, print that out,
	and then call StackTrace
*/
void InstrmntStackTrace(FILE *fp, Proc *pProc, DEBUG_EVENT *pde)
{
	HANDLE hThread;
	Thread Th;
	Thread *pTh;
	CONTEXT context;
	DWORD dw;
	int i;
	int f;
	

	Th.dwThreadId = pde->dwThreadId;
	pTh = (Thread *) bsearch(&Th, vrgTh, vcThread,
							   sizeof(Thread), iThIdCmp);

	if (pTh == NULL)
		return;

	hThread = pTh->hThread;

	memset(&context, 0, sizeof(CONTEXT));
	context.ContextFlags = CONTEXT_FULL;

	if (!GetThreadContext(hThread, &context))
		{
		// well, we didn't even get off the ground
		dw = GetLastError();
		return;
		}

	f = 0;
	for (i = 0; i < CINSTRMNTS; i++)
		{
		if (pProc->rgdwInstrmnt[i] + 1 == context.Eip)
			{
			f = 1;

			if (vrgimp[i].fp != NULL) // now do extra stuff if we have any
				vrgimp[i].fp(fp, pde);

			StackTrace(fp, pde);
			// now we put back the instruction
			if (!WriteProcessMemory(pProc->hProc,
									(VOID *) pProc->rgdwInstrmnt[i],
									&(pProc->rgbInstr[i]),
									sizeof(BYTE),
									NULL))
				{
				// can't instrument
				dw = GetLastError();
				fprintf(fp, "Warning!  Can not patch back breakpoint"
						" for import: %s\n", vrgimp[i].sz); 
				}
			else
				{
				context.Eip--;
				context.EFlags |= TRAPFLAG;
				pProc->dwSingleStepAddr = context.Eip;
				if (!SetThreadContext(hThread, &context))
					{
					fprintf(fp, "Can not reset breakpointed thread_1!\n");
					}
				}
			}
		} // close for loop
	if (f == 0)
		{
		fprintf(fp, "Unknown breakpoint!\n");
		}
	return;
}


/*
	We've had our breakpoint, we've gone past it, now we have to put it back
	so we can breakpoint when we next come down this path
*/
void Repatch(FILE *fp, Proc *pProc, DEBUG_EVENT *pde)
{
	HANDLE hThread;
	Thread Th;
	Thread *pTh;
	CONTEXT context;
	DWORD dw;
	int f;
	BYTE b;

	Th.dwThreadId = pde->dwThreadId;
	pTh = (Thread *) bsearch(&Th, vrgTh, vcThread,
							   sizeof(Thread), iThIdCmp);

	if (pTh == NULL)
		return;

	hThread = pTh->hThread;

	memset(&context, 0, sizeof(CONTEXT));
	context.ContextFlags = CONTEXT_FULL;

	if (!GetThreadContext(hThread, &context))
		{
		// well, we didn't even get off the ground
		return;
		}

	f = 0;

	if (context.Eip - pProc->dwSingleStepAddr < 14)
		{
		b = INT3;
		if (!WriteProcessMemory(pProc->hProc,
								(VOID *) pProc->dwSingleStepAddr,
								&b,
								sizeof(BYTE),
								NULL))
			{
			// can't instrument
			dw = GetLastError();
			fprintf(fp, "Warning!  Can not restore breakpoint\n");
			}
		context.EFlags &= (~TRAPFLAG);
		if (!SetThreadContext(hThread, &context))
			{
			fprintf(fp, "Can not restore breakpoint context!\n");
			}
		else
			{
			pProc->dwSingleStepAddr = 0;
			}
		}
	else
		{
		fprintf(fp, "Unknown SingleStep breakpoint!  Ignoring.\n");
		PrintContext(fp, &context);
		}
	return;
}


/*
	main
	contains the flag setting, process creation, and wait for debug event loop
*/
main(int cArgs, char **pszArgs)
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	DEBUG_EVENT de;
	DWORD dwContinue;
	DWORD dw; // this variable used only for GetLastError calls
	BYTE buff[BUFF_SIZE];
	char szModName[BUFF_SIZE / 2];
	HANDLE hProc;
	HANDLE hThread;
	CONTEXT context;
	VOID *voidp;
	FILE *fpOut;
	Proc *pProc;
	Module *pModule;
	Thread Th;
	Thread *pTh;


	char szCmdLine[2048];
	char *pch;
	char *sz;
	int i;
	int iStart = 1;
	int fExit;
	int cProcesses = 0;
	

	fPsapiEnsured = FALSE;
	vmd = mdDefault;
	vcModule = 0;
	vcProc = 0;
	vcThread = 0;
	vtime_tStart = 0;
	memset(&vsystimeStart, 0, sizeof(SYSTEMTIME));
	memset(vrgModule, 0, sizeof(Module) * CMODULES);
	memset(vrgTh, 0, sizeof(Thread) * CTHREADS);
	memset(vrgProc, 0, sizeof(Proc) * CPROCESSES);
	
	if (cArgs == 1)
		{
		PrintUsage();
		return 0;
		}
	else if (pszArgs[1][0] == '-' || pszArgs[1][0] == '/')
		{
		if (cArgs < 3)
			{
			PrintUsage();
			return 0;
			}
		vmd = mdNone;
		ParseArgs(&pszArgs[1][1]);
		if (!(vmd & mdRepEvents))  // to handle just 'mode' specification
			vmd += mdDefault;
		iStart  = 2;
		}
	if (vmd & mdOutput)
		{
		if (cArgs < 4)
			{
			PrintUsage();
			return 0;
			}
		iStart = 3;
		fpOut = fopen(pszArgs[2], "w+");
		if (fpOut == NULL)
			{
			printf("Unable to open output file!\n");
			return 0;
			}
		}
	else
		fpOut = stdout;	

	pch = &szCmdLine[0];
	for (i = iStart; i < cArgs; i++)
		{
		strcpy(pch, pszArgs[i]);
		pch += strlen(pszArgs[i]);
		*pch++ = ' ';
		*pch = 0;
		}

	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	if (!CreateProcess(NULL, szCmdLine, NULL, NULL, 1, 
				NORMAL_PRIORITY_CLASS | DEBUG_PROCESS, NULL, NULL, &si, &pi))
		{
		printf("Unable to create process.\n");
		return (1);
		}
		
	GetSystemTime(&vsystimeStart);
	time(&vtime_tStart);
	fExit = 0;
	while(!fExit && WaitForDebugEvent(&de, INFINITE))
		{
		dwContinue = DBG_CONTINUE;
		switch(de.dwDebugEventCode)
			{
			case EXCEPTION_DEBUG_EVENT:
				if (vmd & mdExp)
					{
					sz = vszUnkExp;
					for (i = 0; i < CEXP; i++)
						if (vrgexp[i].dwExpCode ==
								de.u.Exception.ExceptionRecord.ExceptionCode)
							{
							sz = vrgexp[i].szExp;
							break;
							}

					fprintf(fpOut,
							"Exception: %s Raised by Process %d in thread %d", 
							sz,
							de.dwProcessId,
							de.dwThreadId);
					PrintTimeStamp(fpOut, TRUE);
					
					Th.dwThreadId = de.dwThreadId;
					pTh = (Thread *) bsearch(&Th, vrgTh, vcThread,
											 sizeof(Thread), iThIdCmp);
					if (pTh != NULL)
						{					
						hThread = pTh->hThread;
						memset(&context, 0, sizeof(CONTEXT));
						context.ContextFlags = CONTEXT_FULL;
													
						if (GetThreadContext(hThread, &context))
							{
							PrintContext(fpOut, &context);
							}
						}
					}
	            switch (de.u.Exception.ExceptionRecord.ExceptionCode) 
					{
					case EXCEPTION_BREAKPOINT:
						if (!(vmd & mdInstrmnts))
							break;
						pProc = pGetpProc(de.dwProcessId);
						if (pProc == NULL)
							break;
						if (pProc->dwFlags & fStaticDone)
							{
							InstrmntStackTrace(fpOut, pProc, &de); 
							break;
							}
						pProc->dwFlags |= fStaticDone;
						if (!SymInitialize(pProc->hProc, NULL, TRUE))
							{
							dw = GetLastError();
							}
						PatchAllModules(fpOut, de.dwProcessId);
						break;
                	case EXCEPTION_SINGLE_STEP: 
						Repatch(fpOut, pProc, &de);
  						break;
					default:
						dwContinue = DBG_EXCEPTION_NOT_HANDLED;
						break;											
            	} 
			break;
				 
			case CREATE_THREAD_DEBUG_EVENT:
				AddThread(de.dwThreadId, de.u.CreateThread.hThread);
				if (vmd & mdThread)
					{
					fprintf(fpOut, "Thread %d created for process %d",
						de.dwThreadId, de.dwProcessId);
					PrintTimeStamp(fpOut, TRUE);
					}
				break;

        	case CREATE_PROCESS_DEBUG_EVENT:
				AddThread(de.dwThreadId, de.u.CreateProcessInfo.hThread);
				AddProc(fpOut, de.dwProcessId, 
						(DWORD) de.u.CreateProcessInfo.lpBaseOfImage,
						de.u.CreateProcessInfo.hProcess);
				if (vmd & mdProc)
					{   
					fprintf(fpOut, "Creating Process %d", de.dwProcessId);
					PrintTimeStamp(fpOut, TRUE);
					}
				cProcesses++;

				if (!bGetProcHandle(de.dwProcessId, &hProc))
					break;

				if (!SymInitialize(hProc, NULL, FALSE))
					{
					dw = GetLastError();
					}
				GetModuleNameByExport(szModName, fpOut, de.dwProcessId,
									  (DWORD) de.u.CreateProcessInfo.lpBaseOfImage);
				if (szModName[0] == 0)
					break;
				if(!SymLoadModule(hProc,
								  de.u.CreateProcessInfo.hFile,
								  szModName,
								  NULL,
								  0,
								  0))
					{
					dw = GetLastError();
					break;
					}
	
				break;

        	case EXIT_THREAD_DEBUG_EVENT:
				if (vmd & mdInstrmnts)
					{
					RemoveThread(de.dwThreadId);
					}
				if (vmd & mdThread)
					{
					fprintf(fpOut,"Thread %d destroyed for process %d",
						de.dwThreadId,
						de.dwProcessId);
					PrintTimeStamp(fpOut, TRUE);
					}
				break;

        	case EXIT_PROCESS_DEBUG_EVENT: // we should never get here!
				RemoveProc(de.dwProcessId);
				RemoveThread(de.dwThreadId);
				if (vmd & mdProc) 
					{
					fprintf(fpOut,"Exiting Process %d", de.dwProcessId);
					PrintTimeStamp(fpOut, TRUE);
					}
				cProcesses--;
				if (!cProcesses)
					fExit = 1;
				break;
        		 
        	case LOAD_DLL_DEBUG_EVENT:
				
				AddModule(fpOut, de.dwProcessId, 
						  (DWORD) de.u.LoadDll.lpBaseOfDll);

				pModule = pGetpModule(de.dwProcessId, 
									  (DWORD) de.u.LoadDll.lpBaseOfDll);
				
				memset(szModName, 0, BUFF_SIZE / 2);

				if (!bGetProcHandle(de.dwProcessId, &hProc))
					break;

				if (de.u.LoadDll.lpImageName == NULL)
					goto OUT_OF_DLL_NAME_RESOLUTION;
				
				if (!ReadProcessMemory(hProc, 
								  de.u.LoadDll.lpImageName,
								  &voidp,
								  sizeof(VOID *),
								  NULL))
					{
					dw = GetLastError();
					goto OUT_OF_DLL_NAME_RESOLUTION;
					}

				if (voidp == NULL)
                    // so the pointer in the debuggee is NULL...
					goto OUT_OF_DLL_NAME_RESOLUTION; 

				if (!ReadProcessMemory(hProc,
									voidp,
									buff,
									MAX_PATH * 2,
									NULL))
					{
					dw = GetLastError();
					goto OUT_OF_DLL_NAME_RESOLUTION;
					}

				// now we prune off the string, just in case
				buff[MAX_PATH * 2 +1] = 0;
				buff[MAX_PATH * 2 +2] = 0;

				if (de.u.LoadDll.fUnicode)
					{
					sprintf(szModName,"%S", (WCHAR *) buff);
					}
				else
					{
					sprintf(szModName,"%s", (CHAR *) buff);					
					}
OUT_OF_DLL_NAME_RESOLUTION:
				
				if (szModName[0] == 0)
					GetModuleNameByExport(szModName, fpOut, de.dwProcessId,
										  pModule->dwModuleBase);
				if (szModName[0] != 0)
					{
					AddModuleName(de.dwProcessId, pModule->dwModuleBase, 
								  szModName); 
					if (!SymLoadModule(hProc,
									   de.u.LoadDll.hFile,
									   szModName,
									   NULL,
									   0,
									   0))
						{
						dw = GetLastError();
						}
					else
						pModule->dwFlags |=	fSymInit;
					}
				if (vmd & mdDll)
					{
                    fprintf(fpOut,"%s loaded as DLL at base 0x%X", 
							szModName, pModule->dwModuleBase);
					PrintTimeStamp(fpOut, TRUE);
					}
 				break;
        		
        	case UNLOAD_DLL_DEBUG_EVENT:		
				if (vmd & mdDll)
					{
					pModule = pGetpModule(de.dwProcessId, 
										  (DWORD) de.u.UnloadDll.lpBaseOfDll);
					if (pModule->szModName != NULL)
						fprintf(fpOut, "%s unloaded as DLL at base 0x%X",
								pModule->szModName, pModule->dwModuleBase);
					else
						fprintf(fpOut, "UNKNOWN unloaded as DLL at base 0x%X",
								pModule->dwModuleBase);
                    PrintTimeStamp(fpOut, TRUE);
					}

				RemoveModule(fpOut, de.dwProcessId, 
						  (DWORD) de.u.UnloadDll.lpBaseOfDll);
				break;

        	case OUTPUT_DEBUG_STRING_EVENT:
				if (! (vmd & mdDMsg))
					break;	// we don't want this output

				if (de.u.DebugString.nDebugStringLength > BUFF_SIZE)
					{
					break;
					}
				if (!bGetProcHandle(de.dwProcessId, &hProc))
					break;

				if (ReadProcessMemory(hProc, 
								  de.u.DebugString.lpDebugStringData,
								  buff,
								  de.u.DebugString.nDebugStringLength,
								  NULL))
					{
					PrintTimeStamp(fpOut, FALSE);
					if (de.u.DebugString.fUnicode)
						{
						fprintf(fpOut,"%S", (WCHAR *) buff);
							
						}
					else
						{
						fprintf(fpOut,"%s", (CHAR *) buff);					
						}
					}
				break;

        	case RIP_EVENT:
				break;
			default:  // we should never get here, either
				break;
			}
		ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinue);
	}
	return (0);
}

// end of file

// Filename: GetReceipt.java
//
// Description: Declaration of GetReceipt
//
// This file is provided as part of the Microsoft Transaction Server
// Software Development Kit
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT 
// WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES 
// OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR 
// PURPOSE.
//
// Copyright (C) 1997 Microsoft Corporation, All rights reserved

package Account;

import com.ms.mtx.*;
import com.ms.com.*;

import accountlib.*;

public class GetReceipt implements IGetReceipt {
	
	private static final String CLSID = "ab077646-e902-11d0-b5be-00c04fb957d8";

	// GetNextReceipt() performs error handling for TrueGetNextReceipt().  If TrueGetNextReceipt() 
	// throws an exception, then GetNextReceipt() will call SetAbort() and pass the exception up 
	// to the caller.  Otherwise, GetNextReceipt() will simply call SetComplete() and return.

	public int GetNextReceipt () throws ComFailException {

		boolean bSuccess = false;
		int result;


		// First of all, get the object context
		IObjectContext ctxObject = MTx.GetObjectContext();

		try {
			// Call the true function
			result = trueGetNextReceipt ();

			bSuccess = true;
			return result;
		}

		// Upon exit, always call SetComplete if happy, or SetAbort if unhappy.
		// We do this because we never save state across method calls.
		finally {
			if (bSuccess)
				ctxObject.SetComplete();
			else
				ctxObject.SetAbort();
		}
	}


	// trueGetNextReceipt() is the function that performs the actual work for the Account class.
	// If an error occurs during execution, it will throw a ComFailException for GetNextReceipt()
	// to handle.

	// For exposition purposes, two versions of this function are given. You can uncomment either one
	// of these routines.

	// The first version of trueGetNextReceipt uses the MTS Shared Property Manager to hold the
	// shared state. The Shared Property Manager allows one to share state across all instances of
	// components that are in the same package, regardless of what language and tools were used to
	// implement each component. It is also hard to create race conditions with the Shared Property Manager.
	// This example also shows that the interface the the Shared Property Manager is not particularly
	// friendly to the Java programmer.
	
	// The second version of trueGetNextReceipt uses Java static variables to hold the shared state,
	// and a static synchronized method to access and update them. This works well if every component
	// that accesses the shared state is written in Java. Correctly writing code like this also
	// requires a full understanding of static members and methods, of synchronized methods, and of
	// how the two interact. It's relatively easy to get code like this wrong, but this example is
	// simple enough that the code is attractive in this case.


	// trueGetNextReceipt using MTS Shared Properties:
	private int trueGetNextReceipt () throws ComFailException {
		
		ISharedPropertyGroupManager spmMgr = null;
		ISharedPropertyGroup spmGroup = null;		
		ISharedProperty spmPropNextReceipt = null;
		ISharedProperty spmPropMaxNum = null;
		
		IUpdateReceipt objReceiptUpdate = null;

		try {
			// Create SPM group manager
			spmMgr = (ISharedPropertyGroupManager) MTx.GetObjectContext().CreateInstance 
				(SharedPropertyGroupManager.clsid, ISharedPropertyGroupManager.iid);

			// Prepare primnitive types that can be passed in by reference, as per the 
			// function declarations generated by the Java Type Library Wizard for the 
			// "Shared Property Manager Type Library."
			boolean bExists[] = new boolean[1];
			int iLockMode [] = new int [1];
			int iReleaseMode [] = new int [1];
			
			iLockMode [0] = ISharedPropertyGroupManager.LOCKMODE_METHOD;
			iReleaseMode [0] = ISharedPropertyGroupManager.RELEASEMODE_PROCESS;
			
			// Create the shared property group
			spmGroup = spmMgr.CreatePropertyGroup ("Receipt", iLockMode, iReleaseMode, bExists);
			
			// Create the properties
			spmPropNextReceipt = spmGroup.CreateProperty("Next", bExists);
			spmPropMaxNum = spmGroup.CreateProperty("MaxNum", bExists);
			
			// Call GetNextReceipt() if necessary
			Variant vRet = new Variant();
			if (spmPropNextReceipt.getValue().getInt() >= spmPropMaxNum.getValue().getInt()) {
				
				objReceiptUpdate = (IUpdateReceipt) MTx.GetObjectContext().CreateInstance 
					(CUpdateReceipt.clsid, IUpdateReceipt.iid);

				int iRet = objReceiptUpdate.Update ();
				
				// Update Next
				vRet.putInt (iRet);
				spmPropNextReceipt.putValue (vRet);
				
				// Incremement MaxNum by 100
				vRet.putInt (iRet + 100);
				spmPropMaxNum.putValue (vRet);
			}
 
			vRet.putInt (spmPropNextReceipt.getValue().getInt() + 1);
			spmPropNextReceipt.putValue (vRet);
			
			// We are finished and happy
			return spmPropNextReceipt.getValue().getInt();
		}

		finally {
			// The following code is not strictly necessary. By calling ComLib.release here,
			// the object counts seen in the MTX explorer remain correct. Without these release
			// calls, the objects used here would not get released until after the next time
			// the Java garbage collector runs. No other ill effect would be caused by omitting
			// this code.

			// Note that this code will be executed regardless of whether we leave this
			// method via return or via an exception.
			if (spmMgr             != null) ComLib.release (spmMgr);
			if (spmGroup           != null) ComLib.release (spmGroup);
			if (spmPropNextReceipt != null) ComLib.release (spmPropNextReceipt);
			if (spmPropMaxNum      != null) ComLib.release (spmPropMaxNum);
			if (objReceiptUpdate   != null) ComLib.release (objReceiptUpdate);
		}
	}	


/*
	// trueGetNextReceipt, using Java static variables:
	private static int m_nextReceipt;
	private static int m_maxReceipt;
	private static synchronized int trueGetNextReceipt () throws ComFailException {

		IUpdateReceipt objUpdateReceipt = null;

		try {
			if (m_nextReceipt >= m_maxReceipt)
			{
				objUpdateReceipt = (IUpdateReceipt) MTx.GetObjectContext().CreateInstance (
											CUpdateReceipt.clsid, IUpdateReceipt.iid);
				m_nextReceipt = objUpdateReceipt.Update();
				m_maxReceipt = m_nextReceipt + 100;
			}

			return ++m_nextReceipt;
		}

		finally {
			// The following code is not strictly necessary. By calling ComLib.release here,
			// the object counts seen in the MTX explorer remain correct. Without these release
			// calls, the objects used here would not get released until after the next time
			// the Java garbage collector runs. No other ill effect would be caused by omitting
			// this code.

			// Note that this code will be executed regardless of whether we leave this
			// method via return or via an exception.
			if (objUpdateReceipt != null) ComLib.release (objUpdateReceipt);
		}
	}
*/

}
